<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Admin - Qu·∫£n l√Ω Tags</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #121218;
      color: #e0e0e8;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .header h1 {
      color: #e8a0b8;
      font-size: 1.5rem;
    }

    /* Auth */
    .auth-section {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .auth-section input {
      padding: 8px 12px;
      border: 1px solid #2a2a38;
      border-radius: 6px;
      background: #1a1a24;
      color: #e0e0e8;
      width: 200px;
    }

    .auth-section button {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      background: #c06080;
      color: #fff;
      cursor: pointer;
    }

    .auth-section button:hover {
      background: #d07090;
    }

    .auth-status {
      font-size: 0.85rem;
      color: #60c0b0;
    }

    /* Filters */
    .filters {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .filters input,
    .filters select {
      padding: 10px 14px;
      border: 1px solid #2a2a38;
      border-radius: 8px;
      background: #1a1a24;
      color: #e0e0e8;
      font-size: 0.95rem;
    }

    .filters input {
      flex: 1;
      min-width: 200px;
    }

    .filters select {
      min-width: 150px;
    }

    /* Stats */
    .stats {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      font-size: 0.9rem;
      color: #a0a0b0;
    }

    .stats span {
      background: #1a1a24;
      padding: 6px 12px;
      border-radius: 6px;
    }

    /* Table */
    .table-wrapper {
      overflow-x: auto;
      background: #16161e;
      border-radius: 12px;
      margin-bottom: 20px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    th,
    td {
      padding: 12px 10px;
      text-align: left;
      border-bottom: 1px solid #252530;
    }

    th {
      background: #121218;
      color: #e8a0b8;
      font-weight: 600;
      position: sticky;
      top: 0;
    }

    tr:hover {
      background: #1e1e28;
    }

    .novel-title {
      max-width: 300px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .novel-title a {
      color: #60c0b0;
      text-decoration: none;
    }

    .novel-title a:hover {
      text-decoration: underline;
    }

    .author {
      max-width: 150px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: #909098;
    }

    .source-badge {
      font-size: 0.75rem;
      padding: 2px 8px;
      border-radius: 4px;
      background: #252530;
      color: #a0a0a8;
    }

    /* Tags */
    .tags-cell {
      min-width: 300px;
    }

    .tag {
      display: inline-block;
      padding: 3px 8px;
      margin: 2px;
      border-radius: 4px;
      font-size: 0.8rem;
      background: #252530;
      color: #c8c8d0;
      cursor: pointer;
    }

    .tag:hover {
      background: #c06080;
      color: #fff;
    }

    .tag.selected {
      background: #40a090;
      color: #fff;
    }

    .tag.remove {
      background: #c05050;
    }

    /* Edit Mode */
    .edit-btn {
      padding: 4px 10px;
      border: 1px solid #60c0b0;
      border-radius: 4px;
      background: transparent;
      color: #60c0b0;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .edit-btn:hover {
      background: #60c0b0;
      color: #121218;
    }

    .edit-btn.saving {
      opacity: 0.5;
      pointer-events: none;
    }

    .tag-editor {
      display: none;
      margin-top: 8px;
      padding: 10px;
      background: #121218;
      border-radius: 8px;
    }

    .tag-editor.active {
      display: block;
    }

    .tag-editor input {
      width: 100%;
      padding: 8px;
      margin-bottom: 8px;
      border: 1px solid #2a2a38;
      border-radius: 4px;
      background: #1a1a24;
      color: #e0e0e8;
    }

    .tag-options {
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 10px;
    }

    .tag-category {
      margin-bottom: 8px;
    }

    .tag-category-name {
      font-size: 0.75rem;
      color: #909098;
      margin-bottom: 4px;
      text-transform: uppercase;
    }

    .editor-actions {
      display: flex;
      gap: 8px;
    }

    .editor-actions button {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85rem;
    }

    .btn-save {
      background: #40a090;
      color: #fff;
    }

    .btn-cancel {
      background: #404050;
      color: #c0c0c8;
    }

    /* Pagination */
    .pagination {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-top: 20px;
    }

    .pagination button {
      padding: 8px 16px;
      border: 1px solid #2a2a38;
      border-radius: 6px;
      background: #1a1a24;
      color: #e0e0e8;
      cursor: pointer;
    }

    .pagination button:hover:not(:disabled) {
      background: #40a090;
      color: #fff;
    }

    .pagination button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .pagination span {
      color: #909098;
    }

    /* Loading */
    .loading {
      text-align: center;
      padding: 40px;
      color: #909098;
    }

    /* Toast */
    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 12px 20px;
      border-radius: 8px;
      background: #40a090;
      color: #fff;
      font-weight: 500;
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.3s;
    }

    .toast.show {
      transform: translateY(0);
      opacity: 1;
    }

    .toast.error {
      background: #c05050;
      color: #fff;
    }

    /* Auto-tag Panel */
    .auto-tag-panel {
      background: #16161e;
      border: 1px solid #252530;
      border-radius: 12px;
      padding: 16px 20px;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 20px;
      flex-wrap: wrap;
    }

    .auto-tag-stats {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
    }

    .auto-tag-stat {
      text-align: center;
      padding: 8px 16px;
      background: #1a1a24;
      border-radius: 8px;
    }

    .auto-tag-stat .value {
      font-size: 1.5rem;
      font-weight: bold;
      color: #60c0b0;
    }

    .auto-tag-stat .label {
      font-size: 0.75rem;
      color: #909098;
      margin-top: 2px;
    }

    .auto-tag-stat.warning .value {
      color: #e0a050;
    }

    .auto-tag-actions {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-left: auto;
    }

    .auto-tag-actions select {
      padding: 10px 14px;
      border: 1px solid #2a2a38;
      border-radius: 8px;
      background: #1a1a24;
      color: #e0e0e8;
    }

    .btn-auto-tag {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, #c06080 0%, #a05068 100%);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s;
    }

    .btn-auto-tag:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(192, 96, 128, 0.3);
    }

    .btn-auto-tag:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .btn-auto-tag.running {
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.7;
      }
    }

    .btn-dry-run {
      padding: 10px 16px;
      border: 1px solid #60c0b0;
      border-radius: 8px;
      background: transparent;
      color: #60c0b0;
      cursor: pointer;
    }

    .btn-dry-run:hover {
      background: #60c0b022;
    }

    /* Tag Audit Panel */
    .tag-audit-panel {
      background: #16161e;
      border: 1px solid #252530;
      border-radius: 12px;
      padding: 16px 20px;
      margin-bottom: 20px;
    }

    .tag-audit-header {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    .tag-audit-header h3 {
      color: #e0a050;
      font-size: 1rem;
      margin: 0;
    }

    .tag-audit-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .tag-audit-controls select {
      padding: 8px 12px;
      border: 1px solid #2a2a38;
      border-radius: 6px;
      background: #1a1a24;
      color: #e0e0e8;
      min-width: 200px;
    }

    .btn-audit {
      padding: 8px 16px;
      border: 1px solid #e0a050;
      border-radius: 6px;
      background: transparent;
      color: #e0a050;
      cursor: pointer;
    }

    .btn-audit:hover {
      background: #e0a05022;
    }

    .btn-audit:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .audit-results {
      max-height: 400px;
      overflow-y: auto;
      margin-top: 15px;
    }

    .audit-item {
      display: flex;
      align-items: center;
      padding: 10px 12px;
      background: #121218;
      border-radius: 8px;
      margin-bottom: 8px;
      gap: 12px;
    }

    .audit-item:hover {
      background: #1e1e28;
    }

    .audit-item .novel-info {
      flex: 1;
      min-width: 0;
    }

    .audit-item .novel-title {
      color: #60c0b0;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .audit-item .novel-tags {
      font-size: 0.8rem;
      color: #909098;
      margin-top: 4px;
    }

    .audit-item .novel-desc {
      font-size: 0.75rem;
      color: #707078;
      margin-top: 4px;
      max-height: 40px;
      overflow: hidden;
    }

    .audit-actions {
      display: flex;
      gap: 6px;
      flex-shrink: 0;
    }

    .btn-remove-tag {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      background: #c05050;
      color: #fff;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .btn-remove-tag:hover {
      background: #d06060;
    }

    .btn-keep-tag {
      padding: 6px 12px;
      border: 1px solid #60c0b0;
      border-radius: 4px;
      background: transparent;
      color: #60c0b0;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .btn-keep-tag:hover {
      background: #60c0b022;
    }

    .audit-stats {
      display: flex;
      gap: 15px;
      margin-bottom: 10px;
      font-size: 0.85rem;
      color: #909098;
    }

    .audit-stats span {
      background: #1a1a24;
      padding: 4px 10px;
      border-radius: 4px;
    }

    /* Fanfic detection */
    .btn-convert-fanfic {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      background: #8060a0;
      color: #fff;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .btn-convert-fanfic:hover {
      background: #9070b0;
    }

    .fanfic-indicator {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.7rem;
      margin-left: 8px;
    }

    .fanfic-indicator.high {
      background: #8060a0;
      color: #fff;
    }

    .fanfic-indicator.medium {
      background: #c08040;
      color: #fff;
    }

    .fanfic-indicator.low {
      background: #4080c0;
      color: #fff;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 5px;
      margin-bottom: 20px;
      border-bottom: 2px solid #252530;
      padding-bottom: 10px;
    }

    .tab-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px 8px 0 0;
      background: #1a1a24;
      color: #909098;
      cursor: pointer;
      font-size: 0.95rem;
    }

    .tab-btn:hover {
      color: #e0e0e8;
    }

    .tab-btn.active {
      background: #c06080;
      color: #fff;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Tag Management */
    .tag-manager {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
    }

    .tag-create-section {
      flex: 0 0 350px;
      background: #16161e;
      padding: 20px;
      border-radius: 12px;
    }

    .tag-create-section h3 {
      color: #e8a0b8;
      margin-bottom: 15px;
      font-size: 1rem;
    }

    .tag-form-group {
      margin-bottom: 15px;
    }

    .tag-form-group label {
      display: block;
      color: #909098;
      font-size: 0.85rem;
      margin-bottom: 5px;
    }

    .tag-form-group input,
    .tag-form-group select,
    .tag-form-group textarea {
      width: 100%;
      padding: 10px;
      border: 1px solid #2a2a38;
      border-radius: 6px;
      background: #1a1a24;
      color: #e0e0e8;
      font-size: 0.9rem;
    }

    .tag-form-group textarea {
      resize: vertical;
      min-height: 60px;
    }

    .btn-create-tag {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 8px;
      background: #40a090;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
    }

    .btn-create-tag:hover {
      background: #50b0a0;
    }

    .tag-list-section {
      flex: 1;
      min-width: 400px;
    }

    .tag-list-section h3 {
      color: #e8a0b8;
      margin-bottom: 15px;
      font-size: 1rem;
    }

    .tag-list-filters {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    .tag-list-filters input,
    .tag-list-filters select {
      padding: 8px 12px;
      border: 1px solid #2a2a38;
      border-radius: 6px;
      background: #1a1a24;
      color: #e0e0e8;
    }

    .tag-list-filters input {
      flex: 1;
      min-width: 200px;
    }

    .tag-list {
      background: #16161e;
      border-radius: 12px;
      max-height: 500px;
      overflow-y: auto;
    }

    .tag-list-item {
      display: flex;
      align-items: center;
      padding: 12px 15px;
      border-bottom: 1px solid #252530;
      gap: 10px;
    }

    .tag-list-item:hover {
      background: #1e1e28;
    }

    .tag-list-item .tag-name {
      flex: 1;
      color: #60c0b0;
      font-weight: 500;
    }

    .tag-list-item .tag-category {
      font-size: 0.75rem;
      padding: 2px 8px;
      border-radius: 4px;
      background: #252530;
      color: #a0a0a8;
    }

    .tag-list-item .tag-count {
      color: #909098;
      font-size: 0.85rem;
    }

    .tag-list-item .tag-actions {
      display: flex;
      gap: 5px;
    }

    .tag-list-item .tag-actions button {
      padding: 4px 8px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
    }

    .btn-edit-tag {
      background: #40a090;
      color: #fff;
    }

    .btn-delete-tag {
      background: #c05050;
      color: #fff;
    }

    /* Edit Tag Modal */
    .edit-tag-form {
      margin-top: 15px;
    }

    /* Modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      z-index: 1000;
      overflow-y: auto;
      padding: 20px;
    }

    .modal-overlay.active {
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }

    .modal {
      background: #16161e;
      border-radius: 16px;
      max-width: 800px;
      width: 100%;
      margin: 20px auto;
      overflow: hidden;
      border: 1px solid #252530;
    }

    .modal-header {
      background: #121218;
      padding: 16px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h2 {
      color: #e8a0b8;
      font-size: 1.1rem;
      margin: 0;
    }

    .modal-close {
      background: none;
      border: none;
      color: #909098;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
    }

    .modal-close:hover {
      color: #e0e0e8;
    }

    .modal-body {
      padding: 20px;
    }

    /* Novel Info in Modal */
    .novel-info {
      margin-bottom: 20px;
    }

    .novel-info-title {
      color: #60c0b0;
      font-size: 1.2rem;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .novel-info-title a {
      color: inherit;
      text-decoration: none;
    }

    .novel-info-title a:hover {
      text-decoration: underline;
    }

    .novel-info-meta {
      color: #909098;
      font-size: 0.85rem;
      margin-bottom: 12px;
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
    }

    .novel-info-desc {
      background: #121218;
      padding: 12px;
      border-radius: 8px;
      font-size: 0.9rem;
      color: #b0b0b8;
      max-height: 150px;
      overflow-y: auto;
      line-height: 1.5;
      margin-bottom: 15px;
    }

    /* Raw Tags Section */
    .raw-tags-section {
      background: #121218;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 15px;
    }

    .raw-tags-section h4 {
      color: #909098;
      font-size: 0.8rem;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .raw-tag {
      display: inline-block;
      padding: 3px 8px;
      margin: 2px;
      border-radius: 4px;
      font-size: 0.75rem;
      background: #252530;
      color: #a0a0a8;
    }

    /* Tag Editor in Modal */
    .modal-tag-editor {
      margin-top: 15px;
    }

    .modal-tag-editor h4 {
      color: #e8a0b8;
      font-size: 0.9rem;
      margin-bottom: 10px;
    }

    .modal-tag-search {
      width: 100%;
      padding: 10px 14px;
      border: 1px solid #2a2a38;
      border-radius: 8px;
      background: #1a1a24;
      color: #e0e0e8;
      font-size: 0.95rem;
      margin-bottom: 10px;
    }

    .modal-tag-options {
      max-height: 250px;
      overflow-y: auto;
      margin-bottom: 15px;
    }

    .modal-selected-tags {
      background: #121218;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 15px;
      min-height: 50px;
    }

    .modal-selected-tags h4 {
      color: #60c0b0;
      font-size: 0.8rem;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .modal-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .modal-actions button {
      padding: 10px 24px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 500;
    }

    .modal-btn-save {
      background: #40a090;
      color: #fff;
    }

    .modal-btn-save:hover {
      background: #50b0a0;
    }

    .modal-btn-cancel {
      background: #404050;
      color: #c0c0c8;
    }

    .modal-btn-cancel:hover {
      background: #505060;
    }

    /* Recrawl button */
    .btn-recrawl {
      padding: 6px 12px;
      border: 1px solid #e0a050;
      border-radius: 6px;
      background: transparent;
      color: #e0a050;
      cursor: pointer;
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .btn-recrawl:hover {
      background: #e0a05022;
    }

    .btn-recrawl:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-recrawl.running {
      animation: pulse 1s infinite;
    }

    .missing-data {
      color: #e8a0b8;
      font-style: italic;
    }

    /* Login Overlay */
    .login-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #121218;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .login-overlay.hidden {
      display: none;
    }

    .login-box {
      background: #1a1a24;
      border: 1px solid #2a2a38;
      border-radius: 16px;
      padding: 40px;
      text-align: center;
      max-width: 400px;
      width: 100%;
    }

    .login-box h2 {
      color: #e8a0b8;
      margin-bottom: 10px;
    }

    .login-box p {
      color: #909098;
      margin-bottom: 25px;
      font-size: 0.9rem;
    }

    .login-box input {
      width: 100%;
      padding: 14px;
      border: 1px solid #2a2a38;
      border-radius: 8px;
      background: #121218;
      color: #e0e0e8;
      font-size: 1rem;
      margin-bottom: 15px;
    }

    .login-box button {
      width: 100%;
      padding: 14px;
      border: none;
      border-radius: 8px;
      background: #c06080;
      color: #fff;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
    }

    .login-box button:hover {
      background: #d07090;
    }

    .login-box .error {
      color: #e06060;
      font-size: 0.85rem;
      margin-top: 10px;
      display: none;
    }

    .login-box .error.show {
      display: block;
    }

    /* Main content hidden by default */
    .main-content {
      display: none;
    }

    .main-content.visible {
      display: block;
    }

    /* Report Tab Styles */
    .report-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 18px;
      height: 18px;
      padding: 0 5px;
      margin-left: 6px;
      font-size: 0.7rem;
      font-weight: bold;
      border-radius: 9px;
      background: #e0a050;
      color: #121218;
    }

    .report-stats-panel {
      background: #16161e;
      border: 1px solid #252530;
      border-radius: 12px;
      padding: 16px 20px;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 20px;
      flex-wrap: wrap;
    }

    .report-list {
      background: #16161e;
      border-radius: 12px;
      min-height: 200px;
    }

    .report-item {
      display: flex;
      gap: 15px;
      padding: 16px 20px;
      border-bottom: 1px solid #252530;
      transition: background 0.2s;
    }

    .report-item:last-child {
      border-bottom: none;
    }

    .report-item:hover {
      background: #1e1e28;
    }

    .report-item-cover {
      width: 60px;
      height: 80px;
      border-radius: 6px;
      background: #252530;
      flex-shrink: 0;
      overflow: hidden;
    }

    .report-item-cover img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .report-item-content {
      flex: 1;
      min-width: 0;
    }

    .report-item-title {
      font-weight: 600;
      color: #60c0b0;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .report-item-title a {
      color: inherit;
      text-decoration: none;
    }

    .report-item-title a:hover {
      text-decoration: underline;
    }

    .report-status-badge {
      font-size: 0.7rem;
      padding: 2px 8px;
      border-radius: 4px;
      font-weight: 500;
    }

    .report-status-pending {
      background: #e0a050;
      color: #121218;
    }

    .report-status-reviewed {
      background: #6080c0;
      color: #fff;
    }

    .report-status-resolved {
      background: #40a090;
      color: #fff;
    }

    .report-status-rejected {
      background: #c05050;
      color: #fff;
    }

    .report-item-meta {
      font-size: 0.8rem;
      color: #909098;
      margin-bottom: 8px;
    }

    .report-item-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-bottom: 8px;
    }

    .report-wrong-tag {
      font-size: 0.75rem;
      padding: 2px 8px;
      border-radius: 4px;
      background: #c05050;
      color: #fff;
    }

    .report-current-tag {
      font-size: 0.75rem;
      padding: 2px 8px;
      border-radius: 4px;
      background: #252530;
      color: #a0a0a8;
    }

    .report-item-reason {
      font-size: 0.85rem;
      color: #b0b0b8;
      padding: 8px 12px;
      background: #1a1a24;
      border-radius: 6px;
      margin-top: 8px;
      font-style: italic;
    }

    .report-item-actions {
      display: flex;
      flex-direction: column;
      gap: 6px;
      flex-shrink: 0;
    }

    .btn-report-action {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      font-size: 0.8rem;
      cursor: pointer;
      white-space: nowrap;
    }

    .btn-report-edit {
      background: #60c0b0;
      color: #121218;
    }

    .btn-report-edit:hover {
      background: #70d0c0;
    }

    .btn-report-resolve {
      background: #40a090;
      color: #fff;
    }

    .btn-report-resolve:hover {
      background: #50b0a0;
    }

    .btn-report-reject {
      background: #404050;
      color: #c0c0c8;
    }

    .btn-report-reject:hover {
      background: #505060;
    }

    .btn-report-delete {
      background: #c05050;
      color: #fff;
    }

    .btn-report-delete:hover {
      background: #d06060;
    }
  </style>
</head>

<body>
  <!-- Login Overlay -->
  <div class="login-overlay" id="loginOverlay">
    <div class="login-box">
      <h2>Admin Panel</h2>
      <p>Nhap Admin Token de truy cap</p>
      <input type="password" id="loginTokenInput" placeholder="Admin Token..."
        onkeypress="if(event.key==='Enter') verifyAndLogin()">
      <button onclick="verifyAndLogin()">Dang nhap</button>
      <div class="error" id="loginError">Token khong hop le</div>
    </div>
  </div>

  <div class="container main-content" id="mainContent">
    <div class="header">
      <h1>Admin Panel</h1>
      <div class="auth-section">
        <button onclick="logout()" style="background:#404050">Dang xuat</button>
        <span class="auth-status" id="authStatus"></span>
      </div>
    </div>

    <!-- Tabs -->
    <div class="tabs">
      <button class="tab-btn active" onclick="switchTab('novels')">Qu·∫£n l√Ω Truy·ªán</button>
      <button class="tab-btn" onclick="switchTab('tags')">Qu·∫£n l√Ω Tags</button>
      <button class="tab-btn" onclick="switchTab('reports')" id="tabBtnReports">
        B√°o c√°o Tag
        <span id="reportBadge" class="report-badge" style="display:none">0</span>
      </button>
      <button class="tab-btn" onclick="switchTab('notice')">Th√¥ng b√°o Web</button>
    </div>

    <!-- Tab: Novels -->
    <div class="tab-content active" id="tab-novels">
      <!-- Auto-tag Panel -->
      <div class="auto-tag-panel" id="autoTagPanel">
        <div class="auto-tag-stats">
          <div class="auto-tag-stat">
            <div class="value" id="statTotal">-</div>
            <div class="label">T·ªïng truy·ªán</div>
          </div>
          <div class="auto-tag-stat">
            <div class="value" id="statWithTags">-</div>
            <div class="label">ƒê√£ c√≥ tag</div>
          </div>
          <div class="auto-tag-stat warning">
            <div class="value" id="statWithoutTags">-</div>
            <div class="label">Ch∆∞a c√≥ tag</div>
          </div>
          <div class="auto-tag-stat">
            <div class="value" id="statPercent">-</div>
            <div class="label">T·ª∑ l·ªá</div>
          </div>
        </div>
        <div class="auto-tag-actions">
          <select id="autoTagLimit">
            <option value="50">50 truy·ªán</option>
            <option value="100" selected>100 truy·ªán</option>
            <option value="200">200 truy·ªán</option>
            <option value="500">500 truy·ªán</option>
            <option value="1000">1000 truy·ªán</option>
            <option value="2000">2000 truy·ªán</option>
          </select>
          <button class="btn-dry-run" onclick="runAutoTag(true)" title="Xem tr∆∞·ªõc k·∫øt qu·∫£ m√† kh√¥ng l∆∞u">
            Dry Run
          </button>
          <button class="btn-auto-tag" id="btnAutoTag" onclick="runAutoTag(false)">
            Auto Tag
          </button>
          <button class="btn-auto-tag" id="btnRetagAll" onclick="runRetagAll()"
            style="background:linear-gradient(135deg, #e0a050 0%, #c08030 100%);"
            title="Re-tag T·∫§T C·∫¢ truy·ªán (k·ªÉ c·∫£ ƒë√£ c√≥ tag)">
            Re-tag All
          </button>
        </div>
      </div>

      <!-- Tag Audit Panel -->
      <div class="tag-audit-panel">
        <div class="tag-audit-header">
          <h3>R√† so√°t Tag (Audit)</h3>
          <div class="tag-audit-controls">
            <select id="auditTagSelect">
              <option value="">-- Ch·ªçn tag c·∫ßn ki·ªÉm tra --</option>
            </select>
            <button class="btn-audit" onclick="runTagAudit(1)">Ki·ªÉm tra</button>
            <button class="btn-audit" onclick="quickScanAudit()" style="border-color:#e8a0b8;color:#e8a0b8"
              title="Qu√©t nhanh 100 truy·ªán, ƒë√°nh d·∫•u nh·ªØng truy·ªán nghi ng·ªù g·∫Øn nh·∫ßm">Qu√©t nhanh</button>
            <button class="btn-audit" onclick="detectFanfics()" style="border-color:#8060a0;color:#8060a0"
              title="T√¨m fanfic trong danh s√°ch ƒêam M·ªπ (t√™n gh√©p, nh√≥m nh·∫°c...)">T√¨m Fanfic</button>
          </div>
        </div>
        <!-- Keyword Search -->
        <div class="tag-audit-header" style="margin-top:12px;padding-top:12px;border-top:1px solid #3a3a5a">
          <h3 style="color:#60c0b0">T√¨m theo t·ª´ kh√≥a</h3>
          <div class="tag-audit-controls">
            <input type="text" id="keywordSearchInput" placeholder="Nh·∫≠p t·ª´ kh√≥a (VD: xuy√™n kh√¥ng, tr√πng sinh...)"
              style="min-width:300px;padding:8px 12px;border:1px solid #444;border-radius:6px;background:#2a2a4a;color:#fff">
            <select id="keywordSearchIn"
              style="padding:8px 12px;border:1px solid #444;border-radius:6px;background:#2a2a4a;color:#fff">
              <option value="all">T√¨m trong t·∫•t c·∫£</option>
              <option value="description">Ch·ªâ m√¥ t·∫£</option>
              <option value="rawTags">Ch·ªâ rawTags</option>
              <option value="title">Ch·ªâ ti√™u ƒë·ªÅ</option>
              <option value="noTag">Ch∆∞a c√≥ tag ch·ª©a t·ª´ kh√≥a</option>
            </select>
            <button class="btn-audit" onclick="searchByKeyword()"
              style="border-color:#60c0b0;color:#60c0b0">T√¨m</button>
          </div>
        </div>
        <div id="auditResults" style="display:none">
          <div class="audit-stats" id="auditStats"></div>
          <div class="audit-results" id="auditResultsList"></div>
          <div class="audit-pagination" id="auditPagination"
            style="display:flex;justify-content:center;gap:10px;margin-top:15px;padding-top:15px;border-top:1px solid #2a2a4a">
            <button class="btn-audit" onclick="auditPrevPage()" id="auditPrevBtn">‚Üê Tr∆∞·ªõc</button>
            <span id="auditPageInfo" style="padding:8px 16px;background:#2a2a4a;border-radius:6px">Trang 1/1</span>
            <button class="btn-audit" onclick="auditNextPage()" id="auditNextBtn">Sau ‚Üí</button>
          </div>
        </div>
      </div>

      <div class="filters">
        <input type="text" id="searchInput" placeholder="T√¨m theo t√™n truy·ªán, t√°c gi·∫£..." onkeyup="debounceSearch()">
        <select id="sourceFilter" onchange="loadNovels()">
          <option value="">T·∫•t c·∫£ ngu·ªìn</option>
        </select>
        <select id="tagFilter" onchange="loadNovels()">
          <option value="">T·∫•t c·∫£ tags</option>
        </select>
        <select id="noTagFilter" onchange="loadNovels()">
          <option value="">C√≥/kh√¥ng tag</option>
          <option value="no">Ch∆∞a c√≥ tag</option>
          <option value="yes">ƒê√£ c√≥ tag</option>
        </select>
        <select id="sortFilter" onchange="loadNovels()">
          <option value="newest">M·ªõi nh·∫•t</option>
          <option value="oldest">C≈© nh·∫•t</option>
          <option value="popular">Hot nh·∫•t</option>
          <option value="title">T√™n A-Z</option>
        </select>
      </div>

      <div class="stats" id="stats"></div>

      <div class="table-wrapper">
        <table>
          <thead>
            <tr>
              <th style="width:50px">#</th>
              <th>T√™n truy·ªán</th>
              <th>T√°c gi·∫£</th>
              <th>Ngu·ªìn</th>
              <th>Tags</th>
              <th style="width:120px">H√†nh ƒë·ªông</th>
            </tr>
          </thead>
          <tbody id="novelList">
            <tr>
              <td colspan="6" class="loading">ƒêang t·∫£i...</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="pagination">
        <button onclick="prevPage()" id="prevBtn">‚Üê Tr∆∞·ªõc</button>
        <span id="pageInfo">Trang 1</span>
        <button onclick="nextPage()" id="nextBtn">Sau ‚Üí</button>
      </div>
    </div>

    <!-- Tab: Tag Management -->
    <div class="tab-content" id="tab-tags">
      <div class="tag-manager">
        <!-- Create New Tag -->
        <div class="tag-create-section">
          <h3>T·∫°o Tag M·ªõi</h3>
          <div class="tag-form-group">
            <label>T√™n tag *</label>
            <input type="text" id="newTagName" placeholder="VD: Xuy√™n Kh√¥ng">
          </div>
          <div class="tag-form-group">
            <label>Th·ªÉ lo·∫°i</label>
            <select id="newTagCategory">
              <option value="type">Th·ªÉ lo·∫°i</option>
              <option value="ending">K·∫øt th√∫c</option>
              <option value="era">Th·ªùi ƒë·∫°i</option>
              <option value="world">Th·∫ø gi·ªõi</option>
              <option value="setting">B·ªëi c·∫£nh</option>
              <option value="genre">Phong c√°ch</option>
              <option value="plot">Xu h∆∞·ªõng</option>
              <option value="relationship">M·ªëi quan h·ªá</option>
              <option value="couple">Couple</option>
              <option value="character">Nh√¢n v·∫≠t</option>
              <option value="content">N·ªôi dung</option>
              <option value="other">Kh√°c</option>
            </select>
          </div>
          <div class="tag-form-group">
            <label>ƒê·ªô ∆∞u ti√™n (1-10)</label>
            <input type="number" id="newTagPriority" value="5" min="1" max="10">
          </div>
          <div class="tag-form-group">
            <label>Aliases (c√°ch nhau b·ªüi d·∫•u ph·∫©y)</label>
            <textarea id="newTagAliases" placeholder="VD: xuyen khong, xuyenkhong, time travel"></textarea>
          </div>
          <div class="tag-form-group">
            <label>M√¥ t·∫£</label>
            <textarea id="newTagDesc" placeholder="M√¥ t·∫£ tag..."></textarea>
          </div>
          <button class="btn-create-tag" onclick="createNewTag()">T·∫°o Tag</button>
        </div>

        <!-- Tag List -->
        <div class="tag-list-section">
          <h3>Danh s√°ch Tags (TagDictionary)</h3>
          <div class="tag-list-filters">
            <input type="text" id="tagListSearch" placeholder="T√¨m tag..." oninput="filterTagList()">
            <select id="tagListCategory" onchange="filterTagList()">
              <option value="">T·∫•t c·∫£ th·ªÉ lo·∫°i</option>
              <option value="type">Th·ªÉ lo·∫°i</option>
              <option value="ending">K·∫øt th√∫c</option>
              <option value="era">Th·ªùi ƒë·∫°i</option>
              <option value="world">Th·∫ø gi·ªõi</option>
              <option value="setting">B·ªëi c·∫£nh</option>
              <option value="genre">Phong c√°ch</option>
              <option value="plot">Xu h∆∞·ªõng</option>
              <option value="relationship">M·ªëi quan h·ªá</option>
              <option value="couple">Couple</option>
              <option value="character">Nh√¢n v·∫≠t</option>
              <option value="content">N·ªôi dung</option>
              <option value="other">Kh√°c</option>
            </select>
          </div>
          <div class="tag-list" id="tagDictionaryList">
            <div style="padding:20px;color:#888;text-align:center">ƒêang t·∫£i...</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Tab: Reports -->
    <div class="tab-content" id="tab-reports">
      <div class="report-stats-panel">
        <div class="auto-tag-stats">
          <div class="auto-tag-stat warning">
            <div class="value" id="reportStatPending">-</div>
            <div class="label">Ch·ªù x·ª≠ l√Ω</div>
          </div>
          <div class="auto-tag-stat">
            <div class="value" id="reportStatReviewed">-</div>
            <div class="label">ƒê√£ xem</div>
          </div>
          <div class="auto-tag-stat" style="background:#40a09022">
            <div class="value" id="reportStatResolved" style="color:#40a090">-</div>
            <div class="label">ƒê√£ x·ª≠ l√Ω</div>
          </div>
          <div class="auto-tag-stat">
            <div class="value" id="reportStatRejected">-</div>
            <div class="label">T·ª´ ch·ªëi</div>
          </div>
          <div class="auto-tag-stat">
            <div class="value" id="reportStatTotal">-</div>
            <div class="label">T·ªïng</div>
          </div>
        </div>
        <div class="auto-tag-actions">
          <select id="reportStatusFilter" onchange="loadReports()">
            <option value="all">T·∫•t c·∫£ tr·∫°ng th√°i</option>
            <option value="pending" selected>Ch·ªù x·ª≠ l√Ω</option>
            <option value="reviewed">ƒê√£ xem</option>
            <option value="resolved">ƒê√£ x·ª≠ l√Ω</option>
            <option value="rejected">T·ª´ ch·ªëi</option>
          </select>
          <button class="btn-auto-tag" onclick="loadReports()" style="padding:10px 16px">
            üîÑ L√†m m·ªõi
          </button>
        </div>
      </div>

      <div class="report-list" id="reportList">
        <div style="padding:40px;text-align:center;color:#909098">ƒêang t·∫£i b√°o c√°o...</div>
      </div>

      <div class="pagination" id="reportPagination" style="display:none">
        <button onclick="reportPrevPage()" id="reportPrevBtn">‚Üê Tr∆∞·ªõc</button>
        <span id="reportPageInfo">Trang 1</span>
        <button onclick="reportNextPage()" id="reportNextBtn">Sau ‚Üí</button>
      </div>
    </div>

    <!-- Tab: Notice -->
    <div class="tab-content" id="tab-notice">
      <div class="report-stats-panel" style="flex-direction:column;align-items:stretch">
        <h3 style="color:#e8a0b8;margin-bottom:15px;font-size:1.1rem">üì¢ Qu·∫£n l√Ω Th√¥ng b√°o Web</h3>

        <div style="margin-bottom:15px">
          <label style="display:block;color:#909098;font-size:0.85rem;margin-bottom:5px">Ti√™u ƒë·ªÅ th√¥ng b√°o:</label>
          <input type="text" id="noticeTitle" placeholder="VD: Th√¥ng b√°o"
            style="width:100%;padding:10px;border:1px solid #2a2a38;border-radius:8px;background:#121218;color:#e0e0e8;font-size:0.95rem">
        </div>

        <div style="margin-bottom:15px">
          <label style="display:block;color:#909098;font-size:0.85rem;margin-bottom:5px">N·ªôi dung (h·ªó tr·ª£ HTML):</label>
          <textarea id="noticeContent" rows="8"
            placeholder="Nh·∫≠p n·ªôi dung th√¥ng b√°o t·∫°i ƒë√¢y... C√≥ th·ªÉ s·ª≠ d·ª•ng HTML: <b>in ƒë·∫≠m</b>, <i>in nghi√™ng</i>, <a href='...'>link</a>"
            style="width:100%;padding:10px;border:1px solid #2a2a38;border-radius:8px;background:#121218;color:#e0e0e8;font-size:0.95rem;resize:vertical;font-family:inherit"></textarea>
        </div>

        <div style="margin-bottom:20px;display:flex;align-items:center;gap:10px">
          <input type="checkbox" id="noticeActive" style="width:18px;height:18px">
          <label for="noticeActive" style="color:#e0e0e8;font-size:0.95rem;cursor:pointer">B·∫≠t th√¥ng b√°o (hi·ªÉn th·ªã tr√™n
            trang ch·ªß)</label>
        </div>

        <div style="display:flex;gap:10px">
          <button onclick="loadNotice()" class="btn-auto-tag" style="flex:1;background:#404050">üîÑ T·∫£i l·∫°i</button>
          <button onclick="saveNotice()" class="btn-auto-tag" style="flex:2">üíæ L∆∞u th√¥ng b√°o</button>
        </div>

        <div id="noticePreview" style="margin-top:20px;display:none">
          <label style="display:block;color:#909098;font-size:0.85rem;margin-bottom:8px">Xem tr∆∞·ªõc:</label>
          <div id="noticePreviewContent"
            style="background:#1a1a24;border:1px solid #2a2a38;border-radius:8px;padding:15px;color:#b0b0b8;font-size:0.9rem;white-space:pre-wrap;line-height:1.6">
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <!-- Edit Modal -->
  <div class="modal-overlay" id="editModal">
    <div class="modal">
      <div class="modal-header">
        <h2>Ch·ªânh s·ª≠a Tags</h2>
        <div style="display:flex;gap:10px;align-items:center">
          <button class="btn-recrawl" id="btnRecrawl" onclick="recrawlNovel()" title="Crawl l·∫°i d·ªØ li·ªáu t·ª´ ngu·ªìn g·ªëc">
            Crawl l·∫°i
          </button>
          <button class="modal-close" onclick="closeModal()">&times;</button>
        </div>
      </div>
      <div class="modal-body">
        <div class="novel-info">
          <div class="novel-info-title">
            <a id="modalNovelTitle" href="#" target="_blank">T√™n truy·ªán</a>
          </div>
          <div class="novel-info-meta">
            <span>üë§ <span id="modalNovelAuthor">-</span></span>
            <span>Ngu·ªìn: <span id="modalNovelSource">-</span></span>
            <span>üìñ <span id="modalNovelChapters">-</span> ch∆∞∆°ng</span>
            <span>üëÅÔ∏è <span id="modalNovelReads">-</span> l∆∞·ª£t ƒë·ªçc</span>
          </div>
          <div class="novel-info-desc" id="modalNovelDesc">M√¥ t·∫£ truy·ªán...</div>
        </div>

        <div class="raw-tags-section">
          <h4>Tags g·ªëc (t·ª´ ngu·ªìn)</h4>
          <div id="modalRawTags">-</div>
        </div>

        <div class="modal-tag-editor">
          <h4>Ch·ªçn Standard Tags</h4>
          <input type="text" class="modal-tag-search" placeholder="T√¨m tag..." oninput="filterModalTags(this.value)">
          <div class="modal-tag-options" id="modalTagOptions"></div>

          <div class="modal-selected-tags">
            <h4>Tags ƒë√£ ch·ªçn</h4>
            <div id="modalSelectedTags"><span style="color:#666">Ch∆∞a ch·ªçn tag n√†o</span></div>
          </div>

          <div class="modal-actions">
            <button class="modal-btn-cancel" onclick="closeModal()">Hu·ª∑</button>
            <button class="modal-btn-save" onclick="saveModalTags()">L∆∞u tags</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // State
    let adminToken = localStorage.getItem('adminToken') || '';
    let isAuthenticated = false;
    let novels = [];
    let allTags = {};
    let allSources = [];
    let currentPage = 1;
    let totalPages = 1;
    let totalNovels = 0;
    const limit = 50;
    let searchTimeout = null;
    let editingNovelId = null;
    let editingTags = new Set();

    // API
    const API = '/api';

    async function api(endpoint, options = {}) {
      const headers = { 'Content-Type': 'application/json' };
      if (adminToken) headers['X-Admin-Token'] = adminToken;

      const res = await fetch(API + endpoint, { ...options, headers });
      return res.json();
    }

    // Auth - Login
    async function verifyAndLogin() {
      const token = document.getElementById('loginTokenInput').value.trim();
      const errorEl = document.getElementById('loginError');

      if (!token) {
        errorEl.textContent = 'Vui long nhap token';
        errorEl.classList.add('show');
        return;
      }

      errorEl.classList.remove('show');

      try {
        // Test token by calling a protected endpoint
        const res = await fetch(API + '/admin/novels/stats', {
          headers: {
            'Content-Type': 'application/json',
            'X-Admin-Token': token
          }
        });
        const data = await res.json();

        if (data.success) {
          // Token valid
          adminToken = token;
          localStorage.setItem('adminToken', token);
          isAuthenticated = true;
          showMainContent();
          loadInitialData();
        } else {
          errorEl.textContent = data.error || 'Token khong hop le';
          errorEl.classList.add('show');
        }
      } catch (err) {
        errorEl.textContent = 'Loi ket noi server';
        errorEl.classList.add('show');
      }
    }

    function logout() {
      adminToken = '';
      isAuthenticated = false;
      localStorage.removeItem('adminToken');
      hideMainContent();
    }

    function showMainContent() {
      document.getElementById('loginOverlay').classList.add('hidden');
      document.getElementById('mainContent').classList.add('visible');
    }

    function hideMainContent() {
      document.getElementById('loginOverlay').classList.remove('hidden');
      document.getElementById('mainContent').classList.remove('visible');
      document.getElementById('loginTokenInput').value = '';
    }

    // Check saved token on load
    async function checkSavedToken() {
      if (adminToken) {
        try {
          const res = await fetch(API + '/admin/novels/stats', {
            headers: {
              'Content-Type': 'application/json',
              'X-Admin-Token': adminToken
            }
          });
          const data = await res.json();

          if (data.success) {
            isAuthenticated = true;
            showMainContent();
            loadInitialData();
            return;
          }
        } catch (err) { }
      }
      // Token invalid or not saved
      hideMainContent();
    }

    // Load data - use admin API to get all tags from TagDictionary
    async function loadTags() {
      const data = await api('/admin/tags');
      if (data.success && data.data?.tags) {
        // Build allTags structure from admin tags
        allTags = {};
        const tagFilter = document.getElementById('tagFilter');
        tagFilter.innerHTML = '<option value="">T·∫•t c·∫£ tags</option>';

        for (const tag of data.data.tags) {
          const cat = tag.category || 'other';
          const tagName = tag.standardTag || tag.tag;
          if (!tagName) continue;

          if (!allTags[cat]) {
            allTags[cat] = { name: cat, tags: [] };
          }
          allTags[cat].tags.push({ tag: tagName, name: tagName });
          tagFilter.innerHTML += `<option value="${tagName}">${tagName}</option>`;
        }
      }
    }

    async function loadNovels() {
      const search = document.getElementById('searchInput').value.trim();
      const source = document.getElementById('sourceFilter').value;
      const tag = document.getElementById('tagFilter').value;
      const noTag = document.getElementById('noTagFilter').value;
      const sort = document.getElementById('sortFilter').value;

      let url = `/novels?page=${currentPage}&limit=${limit}`;
      if (search) url += `&search=${encodeURIComponent(search)}`;
      if (source) url += `&source=${encodeURIComponent(source)}`;
      if (tag) url += `&tag=${encodeURIComponent(tag)}`;
      if (noTag === 'no') url += `&noTags=true`;
      if (noTag === 'yes') url += `&hasTags=true`;
      if (sort) url += `&sort=${sort}`;

      document.getElementById('novelList').innerHTML = '<tr><td colspan="6" class="loading">ƒêang t·∫£i...</td></tr>';

      const data = await api(url);

      if (data.success) {
        novels = data.data.novels || [];
        totalNovels = data.data.pagination?.total || novels.length;
        totalPages = data.data.pagination?.pages || 1;

        // Get sources
        if (allSources.length === 0 && data.data.sources) {
          allSources = data.data.sources;
          const sourceFilter = document.getElementById('sourceFilter');
          sourceFilter.innerHTML = '<option value="">T·∫•t c·∫£ ngu·ªìn</option>';
          for (const s of allSources) {
            sourceFilter.innerHTML += `<option value="${s}">${s}</option>`;
          }
        }

        renderNovels();
        updateStats();
        updatePagination();
      }
    }

    function renderNovels() {
      const tbody = document.getElementById('novelList');

      if (novels.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" class="loading">Kh√¥ng c√≥ truy·ªán n√†o</td></tr>';
        return;
      }

      tbody.innerHTML = novels.map((novel, idx) => {
        const tags = novel.standardTags || [];
        const num = (currentPage - 1) * limit + idx + 1;

        return `
          <tr data-id="${novel._id}">
            <td>${num}</td>
            <td class="novel-title">
              <a href="${novel.originalLink || '#'}" target="_blank" title="${novel.title}">${novel.title}</a>
            </td>
            <td class="author" title="${novel.author || ''}">${novel.author || '-'}</td>
            <td><span class="source-badge">${novel.source || '-'}</span></td>
            <td class="tags-cell">
              <div class="tags-display" id="tags-${novel._id}">
                ${tags.length ? tags.map(t => `<span class="tag">${t}</span>`).join('') : '<span style="color:#666">Ch∆∞a c√≥ tag</span>'}
              </div>
            </td>
            <td>
              <button class="edit-btn" onclick="startEdit('${novel._id}')">S·ª≠a</button>
              <button class="edit-btn" style="border-color:#ff4757;color:#ff4757;margin-left:4px" onclick="deleteNovel('${novel._id}', '${novel.title.replace(/'/g, "\\'")}')">X√≥a</button>
            </td>
          </tr>
        `;
      }).join('');
    }

    function updateStats() {
      document.getElementById('stats').innerHTML = `
        <span>T·ªïng: ${totalNovels.toLocaleString()} truy·ªán</span>
        <span>Trang ${currentPage}/${totalPages}</span>
      `;
    }

    function updatePagination() {
      document.getElementById('pageInfo').textContent = `Trang ${currentPage} / ${totalPages}`;
      document.getElementById('prevBtn').disabled = currentPage <= 1;
      document.getElementById('nextBtn').disabled = currentPage >= totalPages;
    }

    function prevPage() {
      if (currentPage > 1) {
        currentPage--;
        loadNovels();
      }
    }

    function nextPage() {
      if (currentPage < totalPages) {
        currentPage++;
        loadNovels();
      }
    }

    function debounceSearch() {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        currentPage = 1;
        loadNovels();
      }, 300);
    }

    // Edit tags - Open Modal
    function startEdit(novelId) {
      editingNovelId = novelId;
      // Try to find novel in main list or audit results
      let novel = novels.find(n => n._id === novelId);
      if (!novel) {
        novel = auditResults.find(n => n._id === novelId);
      }
      if (!novel) {
        showToast('Kh√¥ng t√¨m th·∫•y truy·ªán!', true);
        return;
      }

      editingTags = new Set(novel.standardTags || []);

      // Populate modal with novel info
      document.getElementById('modalNovelTitle').textContent = novel.title;
      document.getElementById('modalNovelTitle').href = novel.originalLink || '#';
      document.getElementById('modalNovelAuthor').textContent = novel.author || '-';
      document.getElementById('modalNovelSource').textContent = novel.source || '-';
      document.getElementById('modalNovelChapters').textContent = novel.chapterCount || 0;
      document.getElementById('modalNovelReads').textContent = (novel.readCount || 0).toLocaleString();
      const hasDesc = novel.description && novel.description.trim().length > 0;
      document.getElementById('modalNovelDesc').innerHTML = hasDesc
        ? novel.description
        : '<span class="missing-data">‚ö†Ô∏è Kh√¥ng c√≥ m√¥ t·∫£ - B·∫•m "Crawl l·∫°i" ƒë·ªÉ l·∫•y d·ªØ li·ªáu</span>';

      // Show raw tags
      const rawTags = novel.rawTags || [];
      document.getElementById('modalRawTags').innerHTML = rawTags.length
        ? rawTags.map(t => `<span class="raw-tag">#${t}</span>`).join('')
        : '<span style="color:#666">Kh√¥ng c√≥ tags g·ªëc</span>';

      // Render tag options
      renderModalTags('');
      renderModalSelectedTags();

      // Show modal
      document.getElementById('editModal').classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    function closeModal() {
      document.getElementById('editModal').classList.remove('active');
      document.body.style.overflow = '';
      editingNovelId = null;
      editingTags.clear();
      document.querySelector('.modal-tag-search').value = '';
    }

    function renderModalTags(filter) {
      const container = document.getElementById('modalTagOptions');
      let html = '';

      const categoryNames = {
        type: 'Th·ªÉ lo·∫°i', ending: 'K·∫øt th√∫c', era: 'Th·ªùi ƒë·∫°i', world: 'Th·∫ø gi·ªõi',
        setting: 'B·ªëi c·∫£nh', genre: 'Phong c√°ch', plot: 'Xu h∆∞·ªõng',
        relationship: 'M·ªëi quan h·ªá', couple: 'Couple', character: 'Nh√¢n v·∫≠t',
        content: 'N·ªôi dung', other: 'Kh√°c'
      };

      const categoryOrder = ['type', 'ending', 'era', 'world', 'setting', 'genre', 'plot', 'relationship', 'couple', 'character', 'content', 'other'];

      for (const cat of categoryOrder) {
        const catData = allTags[cat];
        if (!catData) continue;

        // Handle both structures: array or {name, tags: [...]}
        const tags = Array.isArray(catData) ? catData : (catData.tags || []);
        if (!Array.isArray(tags) || tags.length === 0) continue;

        const filtered = tags.filter(t => {
          const tagName = t.tag || t.name;
          return tagName && (!filter || tagName.toLowerCase().includes(filter.toLowerCase()));
        });

        if (filtered.length === 0) continue;

        const catDisplayName = catData.name || categoryNames[cat] || cat;

        html += `<div class="tag-category">
          <div class="tag-category-name">${catDisplayName}</div>
          ${filtered.map(t => {
          const tagName = t.tag || t.name;
          const selected = editingTags.has(tagName);
          return `<span class="tag ${selected ? 'selected' : ''}" onclick="toggleModalTag('${tagName}')">${tagName}</span>`;
        }).join('')}
        </div>`;
      }

      container.innerHTML = html || '<div style="color:#666;padding:10px">Kh√¥ng t√¨m th·∫•y tag</div>';
    }

    function filterModalTags(filter) {
      renderModalTags(filter);
    }

    function toggleModalTag(tag) {
      if (editingTags.has(tag)) {
        editingTags.delete(tag);
      } else {
        editingTags.add(tag);
      }
      renderModalTags(document.querySelector('.modal-tag-search').value);
      renderModalSelectedTags();
    }

    function renderModalSelectedTags() {
      const container = document.getElementById('modalSelectedTags');
      if (editingTags.size === 0) {
        container.innerHTML = '<span style="color:#666">Ch∆∞a ch·ªçn tag n√†o</span>';
      } else {
        container.innerHTML = Array.from(editingTags).map(t =>
          `<span class="tag selected" onclick="toggleModalTag('${t}')">${t} √ó</span>`
        ).join('');
      }
    }

    // Re-crawl novel to get fresh data
    async function recrawlNovel() {
      if (!adminToken) {
        showToast('C·∫ßn nh·∫≠p Admin Token!', true);
        return;
      }

      if (!editingNovelId) return;

      const novel = novels.find(n => n._id === editingNovelId);
      if (!novel) return;

      if (!novel.originalLink) {
        showToast('Truy·ªán kh√¥ng c√≥ link ngu·ªìn g·ªëc!', true);
        return;
      }

      const btn = document.getElementById('btnRecrawl');
      btn.disabled = true;
      btn.classList.add('running');
      btn.innerHTML = 'ƒêang crawl...';

      try {
        const data = await api(`/admin/novels/${editingNovelId}/recrawl`, {
          method: 'POST'
        });

        if (data.success) {
          showToast('‚úÖ ƒê√£ crawl l·∫°i th√†nh c√¥ng!');

          // Update local novel data
          const updatedNovel = data.data.novel;
          const idx = novels.findIndex(n => n._id === editingNovelId);
          if (idx >= 0) {
            novels[idx] = { ...novels[idx], ...updatedNovel };
          }

          // Update modal display
          if (updatedNovel.description) {
            document.getElementById('modalNovelDesc').textContent = updatedNovel.description;
          }
          if (updatedNovel.author) {
            document.getElementById('modalNovelAuthor').textContent = updatedNovel.author;
          }
          if (updatedNovel.chapterCount) {
            document.getElementById('modalNovelChapters').textContent = updatedNovel.chapterCount;
          }

          // Update raw tags
          const rawTags = updatedNovel.rawTags || [];
          document.getElementById('modalRawTags').innerHTML = rawTags.length
            ? rawTags.map(t => `<span class="raw-tag">#${t}</span>`).join('')
            : '<span style="color:#666">Kh√¥ng c√≥ tags g·ªëc</span>';

          // If new standard tags were extracted, update the selection
          if (updatedNovel.standardTags && updatedNovel.standardTags.length > 0) {
            editingTags = new Set(updatedNovel.standardTags);
            renderModalTags('');
            renderModalSelectedTags();
          }

        } else {
          showToast(data.message || data.error || 'L·ªói khi crawl', true);
        }
      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      } finally {
        btn.disabled = false;
        btn.classList.remove('running');
        btn.innerHTML = 'Crawl l·∫°i';
      }
    }

    async function saveModalTags() {
      if (!adminToken) {
        showToast('C·∫ßn nh·∫≠p Admin Token!', true);
        return;
      }

      if (!editingNovelId) return;

      try {
        const data = await api(`/admin/novels/${editingNovelId}/tags`, {
          method: 'PUT',
          body: JSON.stringify({ standardTags: Array.from(editingTags) })
        });

        if (data.success) {
          // Update local state
          const novel = novels.find(n => n._id === editingNovelId);
          if (novel) novel.standardTags = Array.from(editingTags);

          // Update display in table
          const tagsDisplay = document.getElementById(`tags-${editingNovelId}`);
          if (tagsDisplay) {
            tagsDisplay.innerHTML = editingTags.size
              ? Array.from(editingTags).map(t => `<span class="tag">${t}</span>`).join('')
              : '<span style="color:#666">Ch∆∞a c√≥ tag</span>';
          }

          closeModal();
          showToast('ƒê√£ l∆∞u tags!');
        } else {
          showToast(data.message || data.error || 'L·ªói khi l∆∞u', true);
        }
      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      }
    }

    // Keep old inline functions for backwards compatibility
    function cancelEdit(novelId) { }
    function renderTagOptions(novelId, filter) { }
    function filterTagOptions(novelId, filter) { }
    function toggleTag(novelId, tag) { }
    function renderSelectedTags(novelId) { }
    async function saveTags(novelId) { startEdit(novelId); }

    // ============== TAB SWITCHING ==============
    function switchTab(tabName) {
      // Update buttons
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelector(`.tab-btn[onclick="switchTab('${tabName}')"]`).classList.add('active');

      // Update content
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      document.getElementById(`tab-${tabName}`).classList.add('active');

      // Load data for tags tab
      if (tabName === 'tags') {
        loadTagDictionary();
      }
    }

    // ============== TAG DICTIONARY MANAGEMENT ==============
    let tagDictionary = [];
    let editingTagId = null;

    async function loadTagDictionary() {
      const container = document.getElementById('tagDictionaryList');

      if (!adminToken) {
        container.innerHTML = '<div style="padding:20px;color:#ff6b9d;text-align:center">‚ö†Ô∏è C·∫ßn nh·∫≠p Admin Token tr∆∞·ªõc!</div>';
        return;
      }

      container.innerHTML = '<div style="padding:20px;color:#888;text-align:center">ƒêang t·∫£i...</div>';

      try {
        const data = await api('/admin/tags');
        console.log('loadTagDictionary response:', data);
        if (data.success) {
          tagDictionary = data.data.tags || [];
          console.log('Loaded', tagDictionary.length, 'tags');
          renderTagDictionary();
        } else {
          container.innerHTML = '<div style="padding:20px;color:#ff4757;text-align:center">L·ªói: ' + (data.message || data.error || 'Unknown') + '</div>';
        }
      } catch (err) {
        console.error('loadTagDictionary error:', err);
        container.innerHTML = '<div style="padding:20px;color:#ff4757;text-align:center">L·ªói: ' + err.message + '</div>';
      }
    }

    function renderTagDictionary() {
      const container = document.getElementById('tagDictionaryList');
      const search = document.getElementById('tagListSearch').value.toLowerCase();
      const category = document.getElementById('tagListCategory').value;

      const filtered = tagDictionary.filter(t => {
        if (category && t.category !== category) return false;
        if (search && !t.standardTag.toLowerCase().includes(search) &&
          !(t.aliases || []).some(a => a.toLowerCase().includes(search))) return false;
        return true;
      });

      if (filtered.length === 0) {
        container.innerHTML = '<div style="padding:20px;color:#888;text-align:center">Kh√¥ng c√≥ tag n√†o</div>';
        return;
      }

      const categoryNames = {
        type: 'Th·ªÉ lo·∫°i', ending: 'K·∫øt th√∫c', era: 'Th·ªùi ƒë·∫°i', world: 'Th·∫ø gi·ªõi',
        setting: 'B·ªëi c·∫£nh', genre: 'Phong c√°ch', plot: 'Xu h∆∞·ªõng',
        relationship: 'M·ªëi quan h·ªá', couple: 'Couple', character: 'Nh√¢n v·∫≠t',
        content: 'N·ªôi dung', other: 'Kh√°c'
      };

      container.innerHTML = filtered.map(tag => `
        <div class="tag-list-item" data-id="${tag._id}">
          <span class="tag-name">${tag.standardTag}</span>
          <span class="tag-category">${categoryNames[tag.category] || tag.category}</span>
          <span class="tag-count">P${tag.priority}</span>
          <div class="tag-actions">
            <button class="btn-edit-tag" onclick="editTag('${tag._id}')">S·ª≠a</button>
            <button class="btn-delete-tag" onclick="deleteTag('${tag._id}', '${tag.standardTag}')">X√≥a</button>
          </div>
        </div>
      `).join('');
    }

    function filterTagList() {
      renderTagDictionary();
    }

    async function createNewTag() {
      const name = document.getElementById('newTagName').value.trim();
      const category = document.getElementById('newTagCategory').value;
      const priority = document.getElementById('newTagPriority').value;
      const aliases = document.getElementById('newTagAliases').value;
      const description = document.getElementById('newTagDesc').value;

      if (!name) {
        showToast('C·∫ßn nh·∫≠p t√™n tag!', true);
        return;
      }

      try {
        const data = await api('/admin/tags', {
          method: 'POST',
          body: JSON.stringify({
            standardTag: name,
            category,
            priority,
            aliases,
            description
          })
        });

        if (data.success) {
          showToast('ƒê√£ t·∫°o tag: ' + name);
          // Clear form
          document.getElementById('newTagName').value = '';
          document.getElementById('newTagAliases').value = '';
          document.getElementById('newTagDesc').value = '';
          // Reload list
          loadTagDictionary();
          loadTags(); // Refresh the tag filter dropdown
        } else {
          showToast(data.message || data.error || 'L·ªói', true);
        }
      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      }
    }

    function editTag(tagId) {
      const tag = tagDictionary.find(t => t._id === tagId);
      if (!tag) return;

      editingTagId = tagId;

      // Populate form with existing values
      document.getElementById('newTagName').value = tag.standardTag;
      document.getElementById('newTagCategory').value = tag.category;
      document.getElementById('newTagPriority').value = tag.priority;
      document.getElementById('newTagAliases').value = (tag.aliases || []).join(', ');
      document.getElementById('newTagDesc').value = tag.description || '';

      // Change button to "Update"
      const btn = document.querySelector('.btn-create-tag');
      btn.textContent = 'C·∫≠p nh·∫≠t Tag';
      btn.onclick = updateEditingTag;

      // Add cancel button if not exists
      if (!document.getElementById('cancelEditBtn')) {
        const cancelBtn = document.createElement('button');
        cancelBtn.id = 'cancelEditBtn';
        cancelBtn.className = 'btn-create-tag';
        cancelBtn.style.background = '#666';
        cancelBtn.style.marginTop = '10px';
        cancelBtn.textContent = 'H·ªßy s·ª≠a';
        cancelBtn.onclick = cancelEditTag;
        btn.parentNode.appendChild(cancelBtn);
      }

      // Scroll to form
      document.querySelector('.tag-create-section').scrollIntoView({ behavior: 'smooth' });
      showToast('ƒêang s·ª≠a: ' + tag.standardTag);
    }

    async function updateEditingTag() {
      if (!editingTagId) return;

      const name = document.getElementById('newTagName').value.trim();
      const category = document.getElementById('newTagCategory').value;
      const priority = document.getElementById('newTagPriority').value;
      const aliases = document.getElementById('newTagAliases').value;
      const description = document.getElementById('newTagDesc').value;

      if (!name) {
        showToast('C·∫ßn nh·∫≠p t√™n tag!', true);
        return;
      }

      try {
        const data = await api(`/admin/tags/${editingTagId}`, {
          method: 'PUT',
          body: JSON.stringify({
            standardTag: name,
            category,
            priority,
            aliases,
            description
          })
        });

        if (data.success) {
          let msg = 'ƒê√£ c·∫≠p nh·∫≠t tag: ' + name;
          if (data.data?.novelsUpdated > 0) {
            msg += ` (${data.data.novelsUpdated} truy·ªán ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t)`;
          }
          showToast(msg);
          cancelEditTag();
          loadTagDictionary();
          loadTags();
        } else {
          showToast(data.message || data.error || 'L·ªói', true);
        }
      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      }
    }

    function cancelEditTag() {
      editingTagId = null;

      // Clear form
      document.getElementById('newTagName').value = '';
      document.getElementById('newTagCategory').value = 'type';
      document.getElementById('newTagPriority').value = '5';
      document.getElementById('newTagAliases').value = '';
      document.getElementById('newTagDesc').value = '';

      // Reset button
      const btn = document.querySelector('.btn-create-tag');
      btn.textContent = 'T·∫°o Tag';
      btn.onclick = createNewTag;

      // Remove cancel button
      const cancelBtn = document.getElementById('cancelEditBtn');
      if (cancelBtn) cancelBtn.remove();
    }

    async function deleteTag(tagId, tagName) {
      if (!confirm(`X√≥a tag "${tagName}"?\n\nL∆∞u √Ω: Tag s·∫Ω b·ªã v√¥ hi·ªáu h√≥a (soft delete).`)) return;

      try {
        const data = await api(`/admin/tags/${tagId}`, {
          method: 'DELETE'
        });

        if (data.success) {
          showToast('ƒê√£ x√≥a tag: ' + tagName);
          loadTagDictionary();
          loadTags();
        } else {
          showToast(data.message || data.error || 'L·ªói', true);
        }
      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      }
    }

    // Toast
    function showToast(msg, isError = false) {
      const toast = document.getElementById('toast');
      toast.textContent = msg;
      toast.className = 'toast show' + (isError ? ' error' : '');
      setTimeout(() => toast.className = 'toast', 3000);
    }

    // ============== DELETE NOVEL ==============
    async function deleteNovel(novelId, title) {
      if (!adminToken) {
        showToast('C·∫ßn nh·∫≠p Admin Token!', true);
        return;
      }

      if (!confirm(`X√≥a truy·ªán n√†y?\n\n"${title}"\n\nH√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c!`)) {
        return;
      }

      try {
        const data = await api(`/admin/novels/${novelId}`, { method: 'DELETE' });

        if (data.success) {
          showToast('ƒê√£ x√≥a truy·ªán: ' + title);
          // Remove from local array and re-render
          novels = novels.filter(n => n._id !== novelId);
          renderNovels();
          totalNovels--;
          updateStats();
          loadNovelStats();
        } else {
          showToast(data.message || data.error || 'L·ªói khi x√≥a', true);
        }
      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      }
    }

    // ============== TAG AUDIT ==============
    let auditResults = [];
    let currentAuditTag = '';
    let markedCorrect = new Set(); // Track novels marked as correct
    let auditPage = 1;
    let auditTotalPages = 1;
    let auditTotal = 0;
    const auditPageSize = 100;

    async function loadAuditTagOptions() {
      const select = document.getElementById('auditTagSelect');
      select.innerHTML = '<option value="">-- Ch·ªçn tag c·∫ßn ki·ªÉm tra --</option>';

      // Use allTags which is already loaded
      const categoryOrder = ['type', 'ending', 'era', 'world', 'setting', 'genre', 'plot', 'relationship', 'couple', 'character', 'content', 'other'];
      const categoryNames = {
        type: 'Th·ªÉ lo·∫°i', ending: 'K·∫øt th√∫c', era: 'Th·ªùi ƒë·∫°i', world: 'Th·∫ø gi·ªõi',
        setting: 'B·ªëi c·∫£nh', genre: 'Phong c√°ch', plot: 'Xu h∆∞·ªõng',
        relationship: 'M·ªëi quan h·ªá', couple: 'Couple', character: 'Nh√¢n v·∫≠t',
        content: 'N·ªôi dung', other: 'Kh√°c'
      };

      for (const cat of categoryOrder) {
        const catData = allTags[cat];
        if (!catData) continue;

        const tags = Array.isArray(catData) ? catData : (catData.tags || []);
        if (tags.length === 0) continue;

        const optgroup = document.createElement('optgroup');
        optgroup.label = categoryNames[cat] || cat;

        for (const t of tags) {
          const tagName = t.tag || t.name;
          const count = t.count || 0;
          if (tagName) {
            const option = document.createElement('option');
            option.value = tagName;
            option.textContent = `${tagName} (${count})`;
            optgroup.appendChild(option);
          }
        }

        select.appendChild(optgroup);
      }
    }

    async function runTagAudit(page = 1) {
      const tagName = document.getElementById('auditTagSelect').value;

      if (!tagName) {
        showToast('Ch·ªçn tag c·∫ßn ki·ªÉm tra!', true);
        return;
      }

      if (!adminToken) {
        showToast('C·∫ßn nh·∫≠p Admin Token!', true);
        return;
      }

      // Reset if new tag or page 1
      if (currentAuditTag !== tagName || page === 1) {
        markedCorrect.clear();
      }

      currentAuditTag = tagName;
      auditPage = page;

      try {
        // Fetch novels with this tag
        const data = await api(`/novels?tags=${encodeURIComponent(tagName)}&limit=${auditPageSize}&page=${page}`);

        if (!data.success) {
          showToast('L·ªói khi t·∫£i d·ªØ li·ªáu', true);
          return;
        }

        auditResults = data.data.novels || [];
        auditTotal = data.data.pagination?.total || auditResults.length;
        auditTotalPages = Math.ceil(auditTotal / auditPageSize);

        document.getElementById('auditResults').style.display = 'block';
        updateAuditStats();
        renderAuditResults();
        updateAuditPagination();

      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      }
    }

    function auditPrevPage() {
      if (auditPage > 1) {
        runTagAudit(auditPage - 1);
      }
    }

    function auditNextPage() {
      if (auditPage < auditTotalPages) {
        runTagAudit(auditPage + 1);
      }
    }

    function updateAuditPagination() {
      document.getElementById('auditPageInfo').textContent = `Trang ${auditPage}/${auditTotalPages} (${auditTotal} truy·ªán)`;
      document.getElementById('auditPrevBtn').disabled = auditPage <= 1;
      document.getElementById('auditNextBtn').disabled = auditPage >= auditTotalPages;
    }

    // Quick scan - automatically detect suspicious novels
    async function quickScanAudit() {
      const tagName = document.getElementById('auditTagSelect').value;

      if (!tagName) {
        showToast('Ch·ªçn tag c·∫ßn ki·ªÉm tra!', true);
        return;
      }

      if (!adminToken) {
        showToast('C·∫ßn nh·∫≠p Admin Token!', true);
        return;
      }

      currentAuditTag = tagName;
      markedCorrect.clear();
      auditPage = 1;

      showToast('ƒêang qu√©t...');

      try {
        // Fetch more novels for quick scan
        const data = await api(`/novels?tags=${encodeURIComponent(tagName)}&limit=100&page=1`);

        if (!data.success) {
          showToast('L·ªói khi t·∫£i d·ªØ li·ªáu', true);
          return;
        }

        const allNovels = data.data.novels || [];
        auditTotal = data.data.pagination?.total || allNovels.length;
        auditTotalPages = Math.ceil(auditTotal / auditPageSize);

        // Analyze each novel using precise matching
        const suspicious = [];
        const confirmed = [];

        for (const novel of allNovels) {
          const rawTagsStr = (novel.rawTags || []).join(' ');
          const descStr = novel.description || '';
          const titleStr = novel.title || '';
          const allText = `${rawTagsStr} ${descStr} ${titleStr}`;

          // Use precise matching function
          const found = isTagFoundInText(tagName, allText);

          if (found) {
            confirmed.push(novel);
          } else {
            suspicious.push(novel);
          }
        }

        // Show suspicious ones first
        auditResults = [...suspicious, ...confirmed];

        // Mark confirmed as correct
        confirmed.forEach(n => markedCorrect.add(n._id));

        document.getElementById('auditResults').style.display = 'block';

        const msg = `Qu√©t xong: ${suspicious.length} nghi ng·ªù / ${allNovels.length} truy·ªán. C√°c truy·ªán nghi ng·ªù hi·ªÉn th·ªã tr∆∞·ªõc.`;
        showToast(msg);

        updateAuditStats();
        renderAuditResults();
        updateAuditPagination();

      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      }
    }

    // Helper: normalize string for search (remove Vietnamese tones)
    function normalizeForSearch(str) {
      return str.toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/ƒë/g, 'd')
        .replace(/ƒê/g, 'D');
    }

    // ============== FANFIC DETECTION ==============
    const FANFIC_PATTERNS = {
      // Couple names (shipped names)
      coupleNames: [
        // BTS
        'taekook', 'vkook', 'kookv', 'jikook', 'kookmin', 'namjin', 'yoonmin', 'sope', 'vmin', 'taejin',
        'vminkook', 'yoonkook', 'namkook', 'hopekook', 'junghope',
        // EXO
        'chanbaek', 'baekyeol', 'kaisoo', 'hunhan', 'xiuchen', 'sulay', 'sekai', 'chansoo',
        // NCT
        'markhyuck', 'nomin', 'johnten', 'jaeyong', 'doyoung', 'taeil', 'renjun',
        // SEVENTEEN
        'meanie', 'jihan', 'soonhoon', 'verkwan', 'cheolsoo', 'junhao',
        // Stray Kids
        'minsung', 'hyunlix', 'chanlix', 'seungin', 'binsung',
        // Chinese
        'yizhan', 'zhanyi', 'wangxian', 'bjyx', 'ggdd',
        'zsww', 'yuzhou', 'tianshan',
        // Thai
        'brightwin', 'mewgulf', 'taynew', 'offgun', 'earthmix', 'bkpp', 'forcebook', 'pondphuwin',
        // Other
        'drarry', 'sasunaru', 'narusasu', 'kagehina', 'iwaoi', 'bokuaka', 'kuroken', 'ushiten',
        'viktuuri', 'otayuri', 'destiel', 'sterek', 'stucky', 'thorki',
        'solangelo', 'percabeth', 'wolfstar',
      ],
      // Group/fandom names
      groupNames: [
        'bts', 'bangtan', 'exo', 'nct', 'wayv', 'seventeen', 'svt', 'txt', 'enhypen',
        'stray kids', 'skz', 'ateez', 'the boyz', 'tbz', 'monsta x', 'got7', 'shinee',
        'blackpink', 'twice', 'red velvet', 'aespa', 'itzy', 'ive', 'lesserafim',
        'gmmtv', 'offgun', '2gether', 'sotus', 'lovesick',
        'harry potter', 'hp', 'marvel', 'mcu', 'avengers', 'dc', 'batman',
        'naruto', 'one piece', 'demon slayer', 'kny', 'jujutsu kaisen', 'jjk',
        'haikyuu', 'bnha', 'mha', 'attack on titan', 'aot', 'snk',
        'genshin', 'honkai', 'countryhumans',
        'mdzs', 'the untamed', 'tgcf', 'svsss', 'erha', '2ha', 'word of honor',
        'lck', 'lpl', 't1', 'geng', 'faker', 'zeus', 'keria',
      ],
      // Fanfic keywords
      keywords: [
        'fanfic', 'fanfiction', 'fan fiction', 'ff', 'fic', 'ƒë·ªìng nh√¢n', 'dong nhan',
        'chuy·ªÉn ver', 'chuyen ver', 'convert', 'idol', 'kpop', 'k-pop',
        'au', 'alternate universe', 'ooc', 'oc', 'x reader', 'reader insert',
        'rpf', 'rps', 'real person', 'ship', 'otp',
      ],
      // Name patterns (CamelCase like TaeKook, JiKook)
      namePatterns: [
        /[A-Z][a-z]+[A-Z][a-z]+/,  // CamelCase names
        /[Í∞Ä-Ìû£]+x[Í∞Ä-Ìû£]+/,        // Korean with x
        /\b[A-Z][a-z]{2,}x[A-Z][a-z]{2,}\b/i,  // Name x Name
      ],
    };

    function detectFanficScore(novel) {
      let score = 0;
      let reasons = [];

      const title = (novel.title || '').toLowerCase();
      const titleOrig = novel.title || '';
      const desc = (novel.description || '').toLowerCase();
      const rawTags = (novel.rawTags || []).map(t => t.toLowerCase());
      const rawTagsStr = rawTags.join(' ');
      const allText = `${title} ${desc} ${rawTagsStr}`;

      // Check couple names (high confidence)
      for (const couple of FANFIC_PATTERNS.coupleNames) {
        if (allText.includes(couple)) {
          score += 30;
          reasons.push(`Couple: ${couple}`);
          break; // Only count once
        }
      }

      // Check group names
      for (const group of FANFIC_PATTERNS.groupNames) {
        if (allText.includes(group)) {
          score += 20;
          reasons.push(`Fandom: ${group}`);
          break;
        }
      }

      // Check keywords
      for (const kw of FANFIC_PATTERNS.keywords) {
        if (allText.includes(kw)) {
          score += 25;
          reasons.push(`Keyword: ${kw}`);
          break;
        }
      }

      // Check CamelCase name patterns in title
      for (const pattern of FANFIC_PATTERNS.namePatterns) {
        if (pattern.test(titleOrig)) {
          score += 15;
          reasons.push('T√™n gh√©p CamelCase');
          break;
        }
      }

      // Check if title has brackets with names (common fanfic pattern)
      if (/\[.+\]/.test(titleOrig) || /„Äê.+„Äë/.test(titleOrig)) {
        score += 10;
        reasons.push('C√≥ [...] trong t√™n');
      }

      // Check for "x" between words in title (common ship notation)
      if (/\b\w+\s*x\s*\w+\b/i.test(title) && !title.includes('1x1')) {
        score += 10;
        reasons.push('C√≥ "x" gi·ªØa t√™n');
      }

      return { score, reasons, isFanfic: score >= 25 };
    }

    async function detectFanfics() {
      if (!adminToken) {
        showToast('C·∫ßn nh·∫≠p Admin Token!', true);
        return;
      }

      currentAuditTag = 'ƒêam M·ªπ';
      markedCorrect.clear();
      auditPage = 1;

      showToast('ƒêang qu√©t t√¨m fanfic...');

      try {
        // Fetch ƒêam M·ªπ novels
        const data = await api(`/novels?tags=${encodeURIComponent('ƒêam M·ªπ')}&limit=200&page=1`);

        if (!data.success) {
          showToast('L·ªói khi t·∫£i d·ªØ li·ªáu', true);
          return;
        }

        const allNovels = data.data.novels || [];
        auditTotal = data.data.pagination?.total || allNovels.length;
        auditTotalPages = Math.ceil(auditTotal / auditPageSize);

        // Analyze each novel for fanfic patterns
        const analyzed = allNovels.map(novel => {
          const detection = detectFanficScore(novel);
          return { ...novel, fanficScore: detection.score, fanficReasons: detection.reasons, isFanfic: detection.isFanfic };
        });

        // Sort by score (highest first)
        analyzed.sort((a, b) => b.fanficScore - a.fanficScore);

        // Filter to show only potential fanfics
        const potentialFanfics = analyzed.filter(n => n.fanficScore >= 15);
        const confirmed = analyzed.filter(n => n.fanficScore < 15);

        auditResults = [...potentialFanfics, ...confirmed];

        // Auto-mark non-fanfics as correct
        confirmed.forEach(n => markedCorrect.add(n._id));

        document.getElementById('auditResults').style.display = 'block';
        document.getElementById('auditTagSelect').value = 'ƒêam M·ªπ';

        showToast(`T√¨m th·∫•y ${potentialFanfics.length} truy·ªán nghi ng·ªù l√† fanfic / ${allNovels.length} truy·ªán ƒêam M·ªπ`);

        updateAuditStats();
        renderFanficResults();
        updateAuditPagination();

      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      }
    }

    function renderFanficResults() {
      const container = document.getElementById('auditResultsList');

      const visibleResults = auditResults.filter(n => !markedCorrect.has(n._id));

      if (visibleResults.length === 0) {
        container.innerHTML = `
          <div style="color:#4ecdc4;padding:20px;text-align:center">
            ‚úÖ ƒê√£ ki·ªÉm tra xong!
            ${auditPage < auditTotalPages ? '<br><button class="btn-audit" onclick="auditNextPage()" style="margin-top:10px">Trang ti·∫øp theo ‚Üí</button>' : ''}
          </div>
        `;
        return;
      }

      container.innerHTML = visibleResults.map(novel => {
        const otherTags = (novel.standardTags || []).filter(t => t !== 'ƒêam M·ªπ').slice(0, 5);
        const rawTags = (novel.rawTags || []).slice(0, 8);
        const desc = (novel.description || '').substring(0, 150);
        const score = novel.fanficScore || 0;
        const reasons = novel.fanficReasons || [];

        let indicatorClass = score >= 40 ? 'high' : score >= 25 ? 'medium' : 'low';

        return `
          <div class="audit-item" data-id="${novel._id}" style="${score >= 25 ? 'border-left:3px solid #9b59b6' : ''}">
            <div class="novel-info">
              <div class="novel-title" title="${novel.title}">
                ${novel.title}
                <span class="fanfic-indicator ${indicatorClass}">${score}% fanfic</span>
              </div>
              <div class="novel-tags" style="color:#9b59b6">
                L√Ω do: ${reasons.length ? reasons.join(', ') : 'kh√¥ng r√µ'}
              </div>
              <div class="novel-tags">
                Tags: ${otherTags.length ? otherTags.join(', ') : '<em>kh√¥ng c√≥</em>'}
              </div>
              <div class="novel-tags">
                Raw: ${rawTags.length ? rawTags.map(t => '#' + t).join(' ') : '<em>kh√¥ng c√≥</em>'}
              </div>
              <div class="novel-desc">${desc || '<em>Kh√¥ng c√≥ m√¥ t·∫£</em>'}</div>
            </div>
            <div class="audit-actions" style="flex-direction:column;gap:4px">
              <button class="btn-convert-fanfic" onclick="convertToFanfic('${novel._id}')" title="G·ª° ƒêam M·ªπ + G·∫Øn Fanfic">Fanfic</button>
              <button class="btn-keep-tag" onclick="keepTag('${novel._id}')" title="Gi·ªØ nguy√™n ƒêam M·ªπ">Gi·ªØ ƒêM</button>
              <button class="btn-remove-tag" onclick="removeTagFromNovel('${novel._id}', 'ƒêam M·ªπ')" title="Ch·ªâ g·ª° ƒêam M·ªπ">‚úó G·ª° ƒêM</button>
            </div>
          </div>
        `;
      }).join('');
    }

    async function convertToFanfic(novelId) {
      if (!adminToken) {
        showToast('C·∫ßn Admin Token!', true);
        return;
      }

      const novel = auditResults.find(n => n._id === novelId);
      if (!novel) return;

      // Remove ƒêam M·ªπ, add Fanfic
      let newTags = (novel.standardTags || []).filter(t => t !== 'ƒêam M·ªπ');
      if (!newTags.includes('Fanfic')) {
        newTags.push('Fanfic');
      }

      try {
        const data = await api(`/admin/novels/${novelId}/tags`, {
          method: 'PUT',
          body: JSON.stringify({ standardTags: newTags })
        });

        if (data.success) {
          showToast(`‚úÖ ƒê√£ chuy·ªÉn "${novel.title.substring(0, 25)}..." sang Fanfic`);

          // Remove from list
          auditResults = auditResults.filter(n => n._id !== novelId);
          renderFanficResults();
          updateAuditStats();
        } else {
          showToast(data.message || 'L·ªói', true);
        }
      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      }
    }

    // Helper: get common aliases for a tag (with exclusions)
    function getTagAliases(tagName) {
      const aliasMap = {
        'Th√¥ T·ª•c': { aliases: ['tho tuc', 'thotuc', 'vulgar', 'crude'], excludes: [] },
        'NTR': { aliases: ['ntr', 'netorare', 'cuckold'], excludes: ['ntr-free', 'no ntr', 'khong ntr'] },
        'Ng∆∞·ª£c': { aliases: ['nguoc', 'ng∆∞·ª£c', 'angst'], excludes: ['khong nguoc', 'ko nguoc'] },
        'Smut': { aliases: ['smut', 'h vƒÉn', 'h van', 'r18', 'nc-17', 'explicit'], excludes: [] },
        'Happy Ending': { aliases: ['happy ending', 'happyending', 'k·∫øt ƒë·∫πp'], excludes: [] },
        'Bad Ending': { aliases: ['bad ending', 'badending', 'k·∫øt bu·ªìn'], excludes: [] },
        'ƒêam M·ªπ': { aliases: ['dam my', 'dammy', 'bl', 'boys love', 'yaoi'], excludes: [] },
        'Xuy√™n Kh√¥ng': { aliases: ['xuyen khong', 'xuyenkhong', 'transmigration'], excludes: [] },
        'Tr√πng Sinh': { aliases: ['trung sinh', 'trungsinh', 'rebirth', 'trong sinh'], excludes: [] },
        'ABO': { aliases: ['abo', 'omegaverse'], excludes: [] },
        '1v1': { aliases: ['1v1', '1x1'], excludes: [] },
        'NP': { aliases: ['np '], excludes: [] }, // Note: space after np to avoid matching "npc"
        // IMPORTANT: Precise matching for similar tags
        'H·ªó C√¥ng': { aliases: ['h·ªó c√¥ng', 'ho cong', 'hocong', 'switch', 'ho√°n ƒë·ªïi c√¥ng th·ª•', 'ƒë·ªïi c√¥ng'], excludes: ['h·ªó s·ªßng', 'ho sung', 'ch·ªß c√¥ng', 'chu cong'] },
        'H·ªó S·ªßng': { aliases: ['h·ªó s·ªßng', 'ho sung', 'hosung', 'h·ªó t∆∞∆°ng s·ªßng'], excludes: [] },
        'Ch·ªß C√¥ng': { aliases: ['ch·ªß c√¥ng', 'chu cong', 'chucong'], excludes: ['h·ªó c√¥ng'] },
      };

      const key = Object.keys(aliasMap).find(k => k.toLowerCase() === tagName.toLowerCase());
      return key ? aliasMap[key] : { aliases: [normalizeForSearch(tagName)], excludes: [] };
    }

    // Check if tag keyword is found in text (with precise matching)
    function isTagFoundInText(tagName, text) {
      const textLower = text.toLowerCase();
      const textNorm = normalizeForSearch(text);
      const tagInfo = getTagAliases(tagName);

      // Check exclusions first - if any exclusion is found, return false
      for (const excl of tagInfo.excludes || []) {
        if (textLower.includes(excl) || textNorm.includes(normalizeForSearch(excl))) {
          // Found exclusion, need to check if the actual tag is also present
          // Only return false if ONLY the exclusion is present, not the actual tag
        }
      }

      // Check if any alias is found
      for (const alias of tagInfo.aliases || []) {
        const aliasNorm = normalizeForSearch(alias);

        // Use word boundary check for short aliases
        if (alias.length <= 3) {
          // For short aliases, require word boundary
          const regex = new RegExp(`(^|[\\s,;.!?#@])${aliasNorm}($|[\\s,;.!?#@])`, 'i');
          if (regex.test(textNorm)) {
            return true;
          }
        } else {
          // For longer aliases, simple include is ok
          if (textLower.includes(alias) || textNorm.includes(aliasNorm)) {
            return true;
          }
        }
      }

      // Also check the tag name itself
      const tagLower = tagName.toLowerCase();
      const tagNorm = normalizeForSearch(tagName);

      if (textLower.includes(tagLower) || textNorm.includes(tagNorm)) {
        // But verify it's not actually an exclusion
        for (const excl of tagInfo.excludes || []) {
          const exclNorm = normalizeForSearch(excl);
          // Check if the found text is actually the exclusion, not the tag
          // e.g., "h·ªó s·ªßng" contains "h·ªó" but is not "h·ªó c√¥ng"
          if (textNorm.includes(exclNorm)) {
            // Found exclusion - need more precise check
            // Check if tag appears WITHOUT being part of exclusion
            const tagPattern = new RegExp(`(^|[\\s,;.!?#@])${tagNorm}($|[\\s,;.!?#@])`, 'i');
            if (!tagPattern.test(textNorm)) {
              return false;
            }
          }
        }
        return true;
      }

      return false;
    }

    function renderAuditResults() {
      const container = document.getElementById('auditResultsList');

      // Filter out novels marked as correct
      const visibleResults = auditResults.filter(n => !markedCorrect.has(n._id));

      if (visibleResults.length === 0) {
        container.innerHTML = `
          <div style="color:#4ecdc4;padding:20px;text-align:center">
            ‚úÖ ƒê√£ ki·ªÉm tra xong trang n√†y!
            ${auditPage < auditTotalPages ? '<br><button class="btn-audit" onclick="auditNextPage()" style="margin-top:10px">Trang ti·∫øp theo ‚Üí</button>' : ''}
          </div>
        `;
        return;
      }

      container.innerHTML = visibleResults.map(novel => {
        const otherTags = (novel.standardTags || []).filter(t => t !== currentAuditTag).slice(0, 5);
        const rawTags = (novel.rawTags || []).slice(0, 8);
        const desc = (novel.description || '').substring(0, 150);

        // Check if tag keyword is found using precise matching
        const rawStr = rawTags.join(' ');
        const allText = `${rawStr} ${desc}`;
        const found = isTagFoundInText(currentAuditTag, allText);

        // Get tag info for highlighting
        const tagInfo = getTagAliases(currentAuditTag);
        const allAliases = [...(tagInfo.aliases || []), currentAuditTag.toLowerCase(), normalizeForSearch(currentAuditTag)];

        // Highlight raw tags that match (but not exclusions)
        const highlightedRaw = rawTags.map(t => {
          const tLower = t.toLowerCase();
          const tNorm = normalizeForSearch(t);

          // Check if this is an exclusion
          const isExclusion = (tagInfo.excludes || []).some(excl =>
            tLower.includes(excl) || tNorm.includes(normalizeForSearch(excl))
          );

          if (isExclusion) {
            return `<span style="color:#ff4757;font-weight:bold" title="Kh√°c v·ªõi ${currentAuditTag}!">#${t}</span>`;
          }

          // Check if matches
          const isMatch = allAliases.some(alias =>
            tLower.includes(alias) || tNorm.includes(normalizeForSearch(alias))
          );

          if (isMatch) {
            return `<span style="color:#4ecdc4;font-weight:bold">#${t}</span>`;
          }
          return `#${t}`;
        }).join(' ');

        return `
          <div class="audit-item" data-id="${novel._id}" style="${!found ? 'border-left:3px solid #ff4757' : ''}">
            <div class="novel-info">
              <div class="novel-title" title="${novel.title}">
                ${!found ? '<span style="color:#ff4757" title="Kh√¥ng t√¨m th·∫•y t·ª´ kh√≥a">‚ö†Ô∏è</span> ' : ''}
                ${novel.title}
              </div>
              <div class="novel-tags">
                Tags kh√°c: ${otherTags.length ? otherTags.join(', ') : '<em>kh√¥ng c√≥</em>'}
              </div>
              <div class="novel-tags">
                Raw: ${rawTags.length ? highlightedRaw : '<em style="color:#ff4757">kh√¥ng c√≥ rawTags</em>'}
              </div>
              <div class="novel-desc">${desc || '<em>Kh√¥ng c√≥ m√¥ t·∫£</em>'}</div>
            </div>
            <div class="audit-actions">
              <button class="btn-keep-tag" onclick="keepTag('${novel._id}')" title="Tag ƒë√∫ng, gi·ªØ l·∫°i">ƒê√∫ng</button>
              <button class="btn-remove-tag" onclick="removeTagFromNovel('${novel._id}', '${currentAuditTag}')" title="G·ª° tag n√†y kh·ªèi truy·ªán">‚úó G·ª° tag</button>
            </div>
          </div>
        `;
      }).join('');
    }

    function keepTag(novelId) {
      // Add to marked correct set and re-render
      markedCorrect.add(novelId);
      renderAuditResults();
      updateAuditStats();
      showToast('ƒê√£ ƒë√°nh d·∫•u ƒë√∫ng');
    }

    function updateAuditStats() {
      const remaining = auditResults.filter(n => !markedCorrect.has(n._id)).length;
      const correctInPage = auditResults.filter(n => markedCorrect.has(n._id)).length;
      document.getElementById('auditStats').innerHTML = `
        <span>Tag: <strong style="color:#ffa502">${currentAuditTag}</strong></span>
        <span>T·ªïng DB: ${auditTotal}</span>
        <span>Trang n√†y: ${auditResults.length}</span>
        <span style="color:#60c0b0">ƒê√∫ng: ${correctInPage}</span>
        <span style="color:#ff6b9d">C·∫ßn xem: ${remaining}</span>
      `;
    }

    async function removeTagFromNovel(novelId, tagToRemove) {
      if (!adminToken) {
        showToast('C·∫ßn Admin Token!', true);
        return;
      }

      const novel = auditResults.find(n => n._id === novelId);
      if (!novel) return;

      const newTags = (novel.standardTags || []).filter(t => t !== tagToRemove);

      try {
        const data = await api(`/admin/novels/${novelId}/tags`, {
          method: 'PUT',
          body: JSON.stringify({ standardTags: newTags })
        });

        if (data.success) {
          showToast(`ƒê√£ g·ª° tag "${tagToRemove}" kh·ªèi "${novel.title.substring(0, 30)}..."`);

          // Remove from audit list
          auditResults = auditResults.filter(n => n._id !== novelId);
          renderAuditResults();
          updateAuditStats();
        } else {
          showToast(data.message || 'L·ªói', true);
        }
      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      }
    }

    // ============== KEYWORD SEARCH ==============
    let keywordSearchMode = '';
    let currentKeyword = '';

    async function searchByKeyword() {
      const keyword = document.getElementById('keywordSearchInput').value.trim();
      const searchIn = document.getElementById('keywordSearchIn').value;

      if (!keyword) {
        showToast('Nh·∫≠p t·ª´ kh√≥a ƒë·ªÉ t√¨m!', true);
        return;
      }

      if (keyword.length < 2) {
        showToast('T·ª´ kh√≥a qu√° ng·∫Øn (t·ªëi thi·ªÉu 2 k√Ω t·ª±)', true);
        return;
      }

      if (!adminToken) {
        showToast('C·∫ßn nh·∫≠p Admin Token!', true);
        return;
      }

      currentKeyword = keyword;
      keywordSearchMode = searchIn;
      markedCorrect.clear();
      auditPage = 1;
      currentAuditTag = `"${keyword}"`;

      showToast(`ƒêang t√¨m "${keyword}"...`);

      try {
        // Use dedicated backend API for keyword search
        const url = `/admin/novels/search-keyword?keyword=${encodeURIComponent(keyword)}&searchIn=${searchIn}&limit=500`;
        const data = await api(url);

        if (!data.success) {
          showToast(data.message || 'L·ªói khi t√¨m ki·∫øm', true);
          return;
        }

        auditResults = data.data.novels || [];
        auditTotal = data.data.total || auditResults.length;
        auditTotalPages = 1;

        document.getElementById('auditResults').style.display = 'block';

        const modeLabels = {
          'all': 't·∫•t c·∫£',
          'description': 'm√¥ t·∫£',
          'rawTags': 'rawTags',
          'title': 'ti√™u ƒë·ªÅ',
          'noTag': 'ch∆∞a c√≥ tag'
        };

        const msg = auditResults.length < auditTotal
          ? `T√¨m th·∫•y ${auditTotal} truy·ªán, hi·ªÉn th·ªã ${auditResults.length} (trong ${modeLabels[searchIn]})`
          : `T√¨m th·∫•y ${auditTotal} truy·ªán ch·ª©a "${keyword}" trong ${modeLabels[searchIn]}`;
        showToast(msg);

        updateKeywordSearchStats();
        renderKeywordSearchResults();
        updateAuditPagination();

      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      }
    }

    function updateKeywordSearchStats() {
      const remaining = auditResults.filter(n => !markedCorrect.has(n._id)).length;
      const correctInPage = auditResults.filter(n => markedCorrect.has(n._id)).length;
      const modeLabels = {
        'all': 't·∫•t c·∫£',
        'description': 'm√¥ t·∫£',
        'rawTags': 'rawTags',
        'title': 'ti√™u ƒë·ªÅ',
        'noTag': 'ch∆∞a c√≥ tag'
      };
      document.getElementById('auditStats').innerHTML = `
        <span>T·ª´ kh√≥a: <strong style="color:#4ecdc4">${currentKeyword}</strong></span>
        <span>T√¨m trong: ${modeLabels[keywordSearchMode] || 't·∫•t c·∫£'}</span>
        <span>T·ªïng: ${auditTotal}</span>
        <span style="color:#60c0b0">Xong: ${correctInPage}</span>
        <span style="color:#ff6b9d">C√≤n l·∫°i: ${remaining}</span>
      `;
    }

    function renderKeywordSearchResults() {
      const container = document.getElementById('auditResultsList');

      const visibleResults = auditResults.filter(n => !markedCorrect.has(n._id));

      if (visibleResults.length === 0) {
        container.innerHTML = `
          <div style="color:#4ecdc4;padding:20px;text-align:center">
            ‚úÖ ƒê√£ xem h·∫øt k·∫øt qu·∫£ t√¨m ki·∫øm!
          </div>
        `;
        return;
      }

      const keywordLower = currentKeyword.toLowerCase();
      const keywordNorm = normalizeForSearch(currentKeyword);

      container.innerHTML = visibleResults.map(novel => {
        const standardTags = (novel.standardTags || []).slice(0, 8);
        const rawTags = (novel.rawTags || []).slice(0, 10);
        const desc = (novel.description || '').substring(0, 200);

        // Highlight keyword in rawTags
        const highlightedRaw = rawTags.map(t => {
          const tLower = t.toLowerCase();
          const tNorm = normalizeForSearch(t);
          if (tLower.includes(keywordLower) || tNorm.includes(keywordNorm)) {
            return `<span style="color:#4ecdc4;font-weight:bold">#${t}</span>`;
          }
          return `#${t}`;
        }).join(' ');

        // Highlight keyword in description
        let highlightedDesc = desc;
        if (desc.toLowerCase().includes(keywordLower)) {
          const regex = new RegExp(`(${currentKeyword})`, 'gi');
          highlightedDesc = desc.replace(regex, '<mark style="background:#4ecdc4;color:#000;padding:0 2px;border-radius:2px">$1</mark>');
        }

        // Check if keyword is already in standardTags
        const hasTagged = standardTags.some(t => {
          const tLower = t.toLowerCase();
          const tNorm = normalizeForSearch(t);
          return tLower.includes(keywordLower) || tNorm.includes(keywordNorm);
        });

        return `
          <div class="audit-item" data-id="${novel._id}" style="${!hasTagged ? 'border-left:3px solid #ffa502' : 'border-left:3px solid #4ecdc4'}">
            <div class="novel-info">
              <div class="novel-title" title="${novel.title}">
                ${hasTagged ? '‚úÖ' : '‚ö†Ô∏è'} ${novel.title}
              </div>
              <div class="novel-tags">
                Standard: ${standardTags.length ? standardTags.map(t => `<span style="background:#3a3a5a;padding:2px 6px;border-radius:3px;font-size:0.75rem;margin:1px">${t}</span>`).join(' ') : '<em style="color:#666">ch∆∞a c√≥</em>'}
              </div>
              <div class="novel-tags">
                Raw: ${rawTags.length ? highlightedRaw : '<em style="color:#666">kh√¥ng c√≥</em>'}
              </div>
              <div class="novel-desc">${highlightedDesc || '<em>Kh√¥ng c√≥ m√¥ t·∫£</em>'}</div>
            </div>
            <div class="audit-actions" style="flex-direction:column;gap:4px">
              <button class="edit-btn" onclick="startEdit('${novel._id}')" title="Ch·ªânh s·ª≠a tags">‚úèÔ∏è S·ª≠a</button>
              <button class="btn-keep-tag" onclick="markKeywordDone('${novel._id}')" title="ƒê√°nh d·∫•u ƒë√£ xem">Xong</button>
            </div>
          </div>
        `;
      }).join('');
    }

    function markKeywordDone(novelId) {
      markedCorrect.add(novelId);
      renderKeywordSearchResults();
      updateKeywordSearchStats();
    }

    // Allow Enter key to trigger search
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => {
        const keywordInput = document.getElementById('keywordSearchInput');
        if (keywordInput) {
          keywordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') searchByKeyword();
          });
        }
      }, 100);
    });

    // ============== AUTO-TAG ==============
    async function loadNovelStats() {
      if (!adminToken) {
        document.getElementById('statTotal').textContent = '-';
        document.getElementById('statWithTags').textContent = '-';
        document.getElementById('statWithoutTags').textContent = '-';
        document.getElementById('statPercent').textContent = '-';
        return;
      }

      try {
        const data = await api('/admin/novels/stats');
        if (data.success) {
          document.getElementById('statTotal').textContent = data.data.total.toLocaleString();
          document.getElementById('statWithTags').textContent = data.data.withTags.toLocaleString();
          document.getElementById('statWithoutTags').textContent = data.data.withoutTags.toLocaleString();
          document.getElementById('statPercent').textContent = data.data.taggedPercent;
        }
      } catch (err) {
        console.error('loadNovelStats error:', err);
      }
    }

    async function runAutoTag(dryRun = false) {
      if (!adminToken) {
        showToast('C·∫ßn nh·∫≠p Admin Token tr∆∞·ªõc!', true);
        return;
      }

      const limit = document.getElementById('autoTagLimit').value;
      const btn = document.getElementById('btnAutoTag');

      btn.disabled = true;
      btn.classList.add('running');
      btn.innerHTML = dryRun ? 'ƒêang qu√©t...' : 'ƒêang x·ª≠ l√Ω...';

      try {
        const data = await api('/admin/novels/auto-tag', {
          method: 'POST',
          body: JSON.stringify({ limit: parseInt(limit), dryRun })
        });

        if (data.success) {
          const { processed, tagged, remaining, results } = data.data;

          let msg = dryRun
            ? `[Dry Run] C√≥ th·ªÉ g·∫Øn tag cho ${tagged}/${processed} truy·ªán`
            : `ƒê√£ g·∫Øn tag cho ${tagged}/${processed} truy·ªán. C√≤n l·∫°i: ${remaining}`;

          showToast(msg);

          // Show results in console for debugging
          console.log('Auto-tag results:', results);

          // Show summary
          if (results && results.length > 0) {
            const withTags = results.filter(r => r.tagsAdded > 0);
            const withoutTags = results.filter(r => r.tagsAdded === 0);

            console.log(`‚úÖ G·∫Øn ƒë∆∞·ª£c tag: ${withTags.length} truy·ªán`);
            if (withTags.length > 0) {
              console.table(withTags.slice(0, 10).map(r => ({
                title: r.title?.substring(0, 40),
                tags: r.tags?.join(', ')
              })));
            }

            console.log(`‚ö†Ô∏è Kh√¥ng t√¨m ƒë∆∞·ª£c tag: ${withoutTags.length} truy·ªán`);
            if (withoutTags.length > 0) {
              // Group by reason
              const noRawTags = withoutTags.filter(r => r.rawTagsCount === 0);
              const hasRawButNoMatch = withoutTags.filter(r => r.rawTagsCount > 0);

              console.log(`   - Kh√¥ng c√≥ rawTags: ${noRawTags.length}`);
              console.log(`   - C√≥ rawTags nh∆∞ng kh√¥ng kh·ªõp: ${hasRawButNoMatch.length}`);

              if (hasRawButNoMatch.length > 0) {
                console.log('\nüìã M·∫´u rawTags kh√¥ng kh·ªõp (c·∫ßn th√™m v√†o TagDictionary):');
                // Collect unique rawTags from unmatched novels
                const unmatchedRawTags = new Set();
                hasRawButNoMatch.forEach(r => {
                  (r.rawTagsSample || []).forEach(t => unmatchedRawTags.add(t));
                });
                console.log(Array.from(unmatchedRawTags).slice(0, 30).join(', '));

                console.table(hasRawButNoMatch.slice(0, 5).map(r => ({
                  title: r.title?.substring(0, 35),
                  rawTags: (r.rawTagsSample || []).slice(0, 5).join(', ')
                })));
              }
            }
          }

          // Refresh stats and novel list
          if (!dryRun) {
            await loadNovelStats();
            await loadNovels();
          }
        } else {
          showToast(data.message || data.error || 'L·ªói', true);
        }
      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      } finally {
        btn.disabled = false;
        btn.classList.remove('running');
        btn.innerHTML = 'Auto Tag';
      }
    }

    // Re-tag ALL novels (including those with existing tags)
    async function runRetagAll() {
      if (!adminToken) {
        showToast('C·∫ßn nh·∫≠p Admin Token tr∆∞·ªõc!', true);
        return;
      }

      const totalNovels = document.getElementById('statTotal')?.textContent || '?';
      const confirmMsg = `B·∫°n c√≥ ch·∫Øc mu·ªën re-tag T·∫§T C·∫¢ ${totalNovels} truy·ªán?\n\nQu√° tr√¨nh n√†y s·∫Ω m·∫•t v√†i ph√∫t.\nTags hi·ªán t·∫°i s·∫Ω ƒë∆∞·ª£c ghi ƒë√®!`;
      if (!confirm(confirmMsg)) return;

      const btn = document.getElementById('btnRetagAll');
      btn.disabled = true;
      btn.classList.add('running');
      btn.innerHTML = 'ƒêang re-tag T·∫§T C·∫¢...';

      try {
        const data = await api('/admin/novels/retag-all', {
          method: 'POST',
          body: JSON.stringify({ dryRun: false })
        });

        if (data.success) {
          const { processed, updated, unchanged, errors, totalWithRawTags, sampleChanges } = data.data;

          showToast(`Ho√†n t·∫•t! ƒê√£ re-tag ${updated}/${processed} truy·ªán (${errors} l·ªói)`);

          // Show results in console
          console.log('Re-tag results:', data.data);
          if (sampleChanges && sampleChanges.length > 0) {
            console.log('Sample changes:');
            console.table(sampleChanges.slice(0, 10).map(c => ({
              title: c.title?.substring(0, 35),
              added: (c.added || []).join(', '),
              removed: (c.removed || []).join(', ')
            })));
          }

          // Refresh stats and novel list
          await loadNovelStats();
          await loadNovels();
        } else {
          showToast(data.message || data.error || 'L·ªói', true);
        }
      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      } finally {
        btn.disabled = false;
        btn.classList.remove('running');
        btn.innerHTML = 'Re-tag All';
      }
    }

    // Load initial data after authentication
    async function loadInitialData() {
      await loadTags();
      await loadNovels();
      await loadNovelStats();
      loadAuditTagOptions();
      await loadReportStats(); // Load report stats for badge
    }

    // ============== REPORTS MANAGEMENT ==============
    let reports = [];
    let reportPage = 1;
    let reportTotalPages = 1;
    let reportTotal = 0;

    async function loadReportStats() {
      try {
        const data = await api('/admin/reports/stats');
        if (data.success) {
          const stats = data.data;
          document.getElementById('reportStatPending').textContent = stats.pending || 0;
          document.getElementById('reportStatReviewed').textContent = stats.reviewed || 0;
          document.getElementById('reportStatResolved').textContent = stats.resolved || 0;
          document.getElementById('reportStatRejected').textContent = stats.rejected || 0;
          document.getElementById('reportStatTotal').textContent = stats.total || 0;

          // Update badge
          const pendingCount = stats.pending || 0;
          const badge = document.getElementById('reportBadge');
          if (pendingCount > 0) {
            badge.textContent = pendingCount > 99 ? '99+' : pendingCount;
            badge.style.display = 'inline-flex';
          } else {
            badge.style.display = 'none';
          }
        }
      } catch (err) {
        console.error('Error loading report stats:', err);
      }
    }

    async function loadReports() {
      const status = document.getElementById('reportStatusFilter').value;
      const listEl = document.getElementById('reportList');
      listEl.innerHTML = '<div style="padding:40px;text-align:center;color:#909098">ƒêang t·∫£i b√°o c√°o...</div>';

      try {
        const data = await api(`/admin/reports?status=${status}&page=${reportPage}&limit=20`);
        if (data.success) {
          reports = data.data.reports || [];
          reportTotal = data.data.pagination.total;
          reportTotalPages = data.data.pagination.totalPages;

          renderReports();
          updateReportPagination();
          await loadReportStats();
        } else {
          listEl.innerHTML = '<div style="padding:40px;text-align:center;color:#c05050">L·ªói t·∫£i b√°o c√°o</div>';
        }
      } catch (err) {
        listEl.innerHTML = `<div style="padding:40px;text-align:center;color:#c05050">L·ªói: ${err.message}</div>`;
      }
    }

    function renderReports() {
      const listEl = document.getElementById('reportList');

      if (reports.length === 0) {
        listEl.innerHTML = '<div style="padding:40px;text-align:center;color:#909098">Kh√¥ng c√≥ b√°o c√°o n√†o</div>';
        document.getElementById('reportPagination').style.display = 'none';
        return;
      }

      listEl.innerHTML = reports.map(report => {
        const novel = report.novelId || {};
        const coverUrl = novel.coverImage ? `/api/image-proxy?url=${encodeURIComponent(novel.coverImage)}` : '';
        const statusClass = `report-status-${report.status}`;
        const statusText = {
          pending: 'Ch·ªù x·ª≠ l√Ω',
          reviewed: 'ƒê√£ xem',
          resolved: 'ƒê√£ x·ª≠ l√Ω',
          rejected: 'T·ª´ ch·ªëi'
        }[report.status] || report.status;

        const wrongTagsHtml = (report.wrongTags || []).map(t =>
          `<span class="report-wrong-tag">‚úó ${t}</span>`
        ).join('');

        const currentTagsHtml = (novel.standardTags || []).map(t => {
          const isWrong = (report.wrongTags || []).includes(t);
          return `<span class="${isWrong ? 'report-wrong-tag' : 'report-current-tag'}">${t}</span>`;
        }).join('');

        const createdDate = new Date(report.createdAt).toLocaleString('vi-VN');

        return `
          <div class="report-item" data-id="${report._id}">
            <div class="report-item-cover">
              ${coverUrl ? `<img src="${coverUrl}" onerror="this.style.display='none'">` : ''}
            </div>
            <div class="report-item-content">
              <div class="report-item-title">
                <a href="${novel.originalLink || '#'}" target="_blank">${novel.title || 'Kh√¥ng r√µ'}</a>
                <span class="report-status-badge ${statusClass}">${statusText}</span>
              </div>
              <div class="report-item-meta">
                B√°o c√°o l√∫c: ${createdDate}
                ${report.reportType ? ` ‚Ä¢ Lo·∫°i: ${report.reportType === 'wrong_tag' ? 'Tag sai' : report.reportType}` : ''}
              </div>
              ${wrongTagsHtml ? `<div style="margin-bottom:6px"><strong style="font-size:0.75rem;color:#c05050">Tags b·ªã b√°o sai:</strong> ${wrongTagsHtml}</div>` : ''}
              <div class="report-item-tags">
                <strong style="font-size:0.75rem;color:#909098;margin-right:6px">Tags hi·ªán t·∫°i:</strong>
                ${currentTagsHtml || '<em style="color:#606068">Kh√¥ng c√≥</em>'}
              </div>
              ${report.reason ? `<div class="report-item-reason">"${report.reason}"</div>` : ''}
              ${report.adminNote ? `<div style="font-size:0.8rem;color:#60c0b0;margin-top:6px">üìù Admin: ${report.adminNote}</div>` : ''}
            </div>
            <div class="report-item-actions">
              ${report.status !== 'resolved' ? `
                <button class="btn-report-action btn-report-edit" onclick="openEditFromReport('${report._id}', '${novel._id}')">‚úèÔ∏è S·ª≠a tags</button>
                <button class="btn-report-action btn-report-resolve" onclick="resolveReport('${report._id}')">‚úì ƒê√°nh d·∫•u x·ª≠ l√Ω</button>
                ${(report.wrongTags && report.wrongTags.length > 0) ?
              `<button class="btn-report-action" style="background:#e0a050;color:#121218" onclick="quickResolveReport('${report._id}', '${novel._id}', '${encodeURIComponent(JSON.stringify(report.wrongTags))}')">‚ö° X·ª≠ l√Ω nhanh</button>`
              : ''}
                ${(report.reason && report.reason.trim().length > 0 && report.reason.trim().length < 30) ?
              `<button class="btn-report-action" style="background:#50e0a0;color:#121218" onclick="quickAddTag('${report._id}', '${novel._id}', '${encodeURIComponent(report.reason.trim())}')">‚ö° Th√™m tag: "${report.reason.trim()}"</button>`
              : ''}
              ` : ''}
              ${report.status === 'pending' ? `
                <button class="btn-report-action btn-report-reject" onclick="updateReportStatus('${report._id}', 'rejected')">‚úó T·ª´ ch·ªëi</button>
              ` : ''}
              <button class="btn-report-action btn-report-delete" onclick="deleteNovelFromReport('${novel._id}', '${report._id}')" title="Xo√° vƒ©nh vi·ªÖn truy·ªán n√†y">üóëÔ∏è Xo√° Truy·ªán</button>
              <button class="btn-report-action" style="background:transparent;border:1px solid #404050;color:#606070;padding:4px 8px" onclick="deleteReport('${report._id}')" title="Ch·ªâ xo√° b√°o c√°o n√†y">x report</button>
            </div>
          </div>
        `;
      }).join('');

      document.getElementById('reportPagination').style.display = 'flex';
    }

    function updateReportPagination() {
      document.getElementById('reportPageInfo').textContent = `Trang ${reportPage}/${reportTotalPages} (${reportTotal} b√°o c√°o)`;
      document.getElementById('reportPrevBtn').disabled = reportPage <= 1;
      document.getElementById('reportNextBtn').disabled = reportPage >= reportTotalPages;
    }

    function reportPrevPage() {
      if (reportPage > 1) {
        reportPage--;
        loadReports();
      }
    }

    function reportNextPage() {
      if (reportPage < reportTotalPages) {
        reportPage++;
        loadReports();
      }
    }

    async function updateReportStatus(reportId, status) {
      try {
        const data = await api(`/admin/reports/${reportId}/status`, {
          method: 'PUT',
          body: JSON.stringify({ status })
        });

        if (data.success) {
          showToast(`ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i: ${status}`);
          await loadReports();
        } else {
          showToast(data.message || 'L·ªói', true);
        }
      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      }
    }

    async function resolveReport(reportId) {
      try {
        const data = await api(`/admin/reports/${reportId}/resolve`, {
          method: 'POST',
          body: JSON.stringify({})
        });

        if (data.success) {
          showToast('ƒê√£ ƒë√°nh d·∫•u x·ª≠ l√Ω xong!');
          await loadReports();
        } else {
          showToast(data.message || 'L·ªói', true);
        }
      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      }
    }

    async function deleteReport(reportId) {
      if (!confirm('B·∫°n c√≥ ch·∫Øc mu·ªën xo√° b√°o c√°o n√†y (kh√¥ng xo√° truy·ªán)?')) return;

      try {
        const data = await api(`/admin/reports/${reportId}`, { method: 'DELETE' });
        if (data.success) {
          showToast('ƒê√£ xo√° b√°o c√°o');
          await loadReports();
        } else {
          showToast(data.message || 'L·ªói', true);
        }
      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      }
    }

    async function deleteNovelFromReport(novelId, reportId) {
      if (!confirm('C·∫¢NH B√ÅO: B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën XO√Å Vƒ®NH VI·ªÑN truy·ªán n√†y kh·ªèi database?\nH√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c!')) return;

      try {
        // 1. Delete Novel
        const novelRes = await api(`/admin/novels/${novelId}`, { method: 'DELETE' });

        if (!novelRes.success) {
          showToast('L·ªói xo√° truy·ªán: ' + (novelRes.message || 'Unknown'), true);
          return;
        }

        // 2. Delete Report
        await api(`/admin/reports/${reportId}`, { method: 'DELETE' });

        showToast('ƒê√£ xo√° truy·ªán v√† b√°o c√°o th√†nh c√¥ng');
        await loadReports();

      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      }
    }

    async function openEditFromReport(reportId, novelId, wrongTags) {
      // Just open the modal to edit tags - don't auto-update status
      // Admin should manually mark as resolved after editing
      if (novelId) {
        await openModal(novelId);
      }
    }

    async function quickResolveReport(reportId, novelId, wrongTagsSafe) {
      if (!confirm('B·∫°n c√≥ ch·∫Øc mu·ªën xo√° c√°c tags b√°o sai v√† ƒë√°nh d·∫•u ƒë√£ x·ª≠ l√Ω?')) return;

      try {
        const wrongTags = JSON.parse(decodeURIComponent(wrongTagsSafe));

        // 1. Get current novel details to get latest tags
        const res = await fetch(`/api/novels/${novelId}`);
        const data = await res.json();

        if (!data.success || !data.data) {
          throw new Error('Kh√¥ng th·ªÉ l·∫•y th√¥ng tin truy·ªán');
        }

        const novel = data.data;
        const currentTags = novel.standardTags || [];

        // 2. Remove wrong tags (Case-insensitive & trim)
        const wrongTagsNormalized = wrongTags.map(t => t.toLowerCase().trim());
        const newTags = currentTags.filter(t => !wrongTagsNormalized.includes(t.toLowerCase().trim()));

        if (newTags.length === currentTags.length) {
          if (!confirm('Kh√¥ng t√¨m th·∫•y tag n√†o trong danh s√°ch tag hi·ªán t·∫°i ƒë·ªÉ xo√°. V·∫´n ƒë√°nh d·∫•u ƒë√£ x·ª≠ l√Ω?')) {
            return;
          }
        }

        // 3. Resolve report with new tags
        const result = await api(`/admin/reports/${reportId}/resolve`, {
          method: 'POST',
          body: JSON.stringify({
            newTags: newTags,
            adminNote: 'Auto: ƒê√£ xo√° tags b√°o sai.'
          })
        });

        if (result.success) {
          showToast('ƒê√£ x·ª≠ l√Ω nhanh th√†nh c√¥ng!');
          await loadReports();
        } else {
          showToast(result.message || 'L·ªói x·ª≠ l√Ω', true);
        }
      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      }
    }

    async function quickAddTag(reportId, novelId, tagNameSafe) {
      let tagName = decodeURIComponent(tagNameSafe);

      tagName = prompt('Nh·∫≠p t√™n Tag mu·ªën th√™m v√†o truy·ªán:', tagName);
      if (!tagName || !tagName.trim()) return;
      tagName = tagName.trim();

      try {
        // 1. Get current novel details
        const res = await fetch(`/api/novels/${novelId}`);
        const data = await res.json();

        if (!data.success || !data.data) {
          throw new Error('Kh√¥ng th·ªÉ l·∫•y th√¥ng tin truy·ªán');
        }

        const novel = data.data;
        const currentTags = novel.standardTags || [];

        // 2. Add new tag if not exists
        let newTags = [...currentTags];
        // Normalize checking
        if (!newTags.some(t => t.toLowerCase() === tagName.toLowerCase())) {
          newTags.push(tagName);
        } else {
          if (!confirm(`Tag "${tagName}" ƒë√£ c√≥ s·∫µn trong truy·ªán. V·∫´n ƒë√°nh d·∫•u ƒë√£ x·ª≠ l√Ω?`)) return;
        }

        // 3. Resolve report
        const result = await api(`/admin/reports/${reportId}/resolve`, {
          method: 'POST',
          body: JSON.stringify({
            newTags: newTags,
            adminNote: `Auto: ƒê√£ th√™m tag "${tagName}" t·ª´ ghi ch√∫ b√°o c√°o.`
          })
        });

        if (result.success) {
          showToast(`ƒê√£ th√™m tag "${tagName}" th√†nh c√¥ng!`);
          await loadReports();
        } else {
          showToast(result.message || 'L·ªói x·ª≠ l√Ω', true);
        }
      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      }
    }

    // ============== NOTICE MANAGEMENT ==============

    async function loadNotice() {
      try {
        const data = await api('/admin/notice');
        if (data.success && data.data) {
          const notice = data.data;
          document.getElementById('noticeTitle').value = notice.title || '';
          document.getElementById('noticeContent').value = notice.content || '';
          document.getElementById('noticeActive').checked = notice.isActive || false;

          // Show preview
          updateNoticePreview();
        }
      } catch (err) {
        console.error('Error loading notice:', err);
      }
    }

    async function saveNotice() {
      const title = document.getElementById('noticeTitle').value.trim();
      const content = document.getElementById('noticeContent').value;
      const isActive = document.getElementById('noticeActive').checked;

      try {
        const data = await api('/admin/notice', {
          method: 'PUT',
          body: JSON.stringify({ title, content, isActive })
        });

        if (data.success) {
          showToast('ƒê√£ l∆∞u th√¥ng b√°o!');
          updateNoticePreview();
        } else {
          showToast(data.message || 'L·ªói', true);
        }
      } catch (err) {
        showToast('L·ªói: ' + err.message, true);
      }
    }

    function updateNoticePreview() {
      const content = document.getElementById('noticeContent').value;
      const previewDiv = document.getElementById('noticePreview');
      const previewContent = document.getElementById('noticePreviewContent');

      if (content.trim()) {
        previewDiv.style.display = 'block';
        previewContent.innerHTML = content;
      } else {
        previewDiv.style.display = 'none';
      }
    }

    // Add event listener for preview
    document.addEventListener('DOMContentLoaded', () => {
      const contentEl = document.getElementById('noticeContent');
      if (contentEl) {
        contentEl.addEventListener('input', updateNoticePreview);
      }
    });

    // Override switchTab to load reports when switching to reports tab
    const originalSwitchTab = typeof switchTab === 'function' ? switchTab : null;
    function switchTab(tabName) {
      // Remove active from all tabs
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

      // Add active to selected tab
      const btn = document.querySelector(`.tab-btn[onclick*="${tabName}"]`);
      if (btn) btn.classList.add('active');

      const content = document.getElementById('tab-' + tabName);
      if (content) content.classList.add('active');

      // Load reports when switching to reports tab
      if (tabName === 'reports') {
        loadReports();
      }

      // Load tag dictionary when switching to tags tab
      if (tabName === 'tags') {
        loadTagDictionary();
      }

      // Load notice when switching to notice tab
      if (tabName === 'notice') {
        loadNotice();
      }
    }

    // Init
    document.addEventListener('DOMContentLoaded', async () => {
      // Check saved token and authenticate
      await checkSavedToken();

      // Close modal on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') closeModal();
      });

      // Close modal when clicking outside
      document.getElementById('editModal').addEventListener('click', (e) => {
        if (e.target.classList.contains('modal-overlay')) {
          closeModal();
        }
      });
    });
  </script>
</body>

</html>